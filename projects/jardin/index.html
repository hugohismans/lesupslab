<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Jardin FÃ©erique â€” Mobile + Stable (Dual Sticks)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    :root{
      --hud-w:320px;
      --hud-bg: rgba(0,0,0,.55);
      --hud-bd: rgba(255,255,255,.08);
      --card: rgba(255,255,255,.04);
      --card-bd: rgba(255,255,255,.06);
    }
    html, body { margin:0; height:100%; background:#05060a; overflow:hidden; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:#fff; }

    /* Overlay entrÃ©e */
    #overlay {
      position: absolute; inset: 0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: rgba(0,0,0,.85); z-index: 10; text-align:center; gap:10px; padding:16px;
    }
    #overlay button {
      padding:10px 16px; border:0; border-radius:10px; font-weight:700; cursor:pointer; color:#0b0d14;
      background: linear-gradient(135deg,#7dd3fc,#34d399);
    }
    #overlay input[type="text"] { padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.08); color:#fff; }
    #overlay input[type="color"] { width:48px; height:32px; border:none; background:transparent; }

    /* Chat */
    #chat {
      position: absolute; left: 12px; bottom: 12px; width: 320px; max-height: 240px;
      background: rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:6px; z-index:5;
    }
    #messages { flex:1; overflow:auto; list-style:none; margin:0; padding:0; font-size:14px; }
    #messages li { margin: 2px 0; }
    #chat form { display:flex; gap:6px; }
    #msg { flex:1; padding:8px; border:1px solid rgba(255,255,255,.15); border-radius:8px; background:rgba(255,255,255,.08); color:#fff; }
    #send { padding:8px 10px; border:0; border-radius:8px; background:#7dd3fc; color:#0b0d14; font-weight:700; cursor:pointer; }

    /* HUD */
    #hud {
      position:absolute; right:12px; top:12px; padding:10px 12px; width: var(--hud-w);
      background:var(--hud-bg); border:1px solid var(--hud-bd); border-radius:10px; font-size:13px;
      display:flex; flex-direction:column; gap:8px; z-index:5; max-height: calc(100vh - 24px); overflow:auto;
      backdrop-filter: blur(2px);
    }
    #who { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:6px; }
    .user { display:flex; align-items:center; gap:8px; background: var(--card); border:1px solid var(--card-bd); padding:6px 8px; border-radius:8px; }
    .dot { width:10px; height:10px; border-radius:50%; box-shadow: 0 0 10px rgba(255,255,255,.4) inset; }
    .me  { outline: 1px dashed rgba(255,255,255,.3); }
    .hint { position:absolute; left:50%; transform:translateX(-50%); bottom:8px; opacity:.85; font-size:12px; background:rgba(0,0,0,.5); padding:4px 8px; border-radius:8px; display:none; z-index:4; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .btn { padding:6px 8px; border:0; border-radius:8px; background:#1f2937; color:#fff; cursor:pointer; font-weight:600; }
    .btn.active { background:#7dd3fc; color:#0b0d14; }
    select { background:#0f172a; color:#fff; border:1px solid rgba(255,255,255,.18); border-radius:8px; padding:6px 8px; }
    input[type="range"]{ width:120px; }

    /* Modal planter fleur */
    #flowerModal { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.55); z-index:20; }
    #flowerModal .card { width:min(92vw, 420px); background:#0b1020; border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:14px; }
    #flowerMsg{ width:100%; resize:vertical; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); color:#fff; border-radius:8px; padding:8px; margin-bottom:10px; }

    /* MOBILE UI (deux joysticks) */
    #mobileUI { position:fixed; inset:0; pointer-events:none; display:none; z-index:6; }
    
    #stickArea, #lookArea {
      width:150px; height:150px; border-radius:50%;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      pointer-events:auto; touch-action:none;
    }
    #stickArea { position:absolute; left:14px; bottom:14px; }
    #lookArea  { position:absolute; right:14px; bottom:14px; }
    #stick, #lookStick {
      position:absolute; left:50%; top:50%; width:72px; height:72px; margin:-36px 0 0 -36px; border-radius:50%;
      transform: translate(0,0);
    }
    #stick    { background:rgba(125,211,252,.25); border:1px solid rgba(125,211,252,.7); box-shadow:0 0 12px rgba(125,211,252,.5) inset; }
    #lookStick{ background:rgba(180,160,255,.25); border:1px solid rgba(180,160,255,.7); box-shadow:0 0 12px rgba(180,160,255,.5) inset; }

    /* Boutons actions au-dessus du joystick droit */
    #actionArea {
      position:absolute; right:14px; bottom:180px; display:flex; flex-direction:column; gap:12px; pointer-events:auto;
    }
    #actionArea .act {
      width:64px; height:64px; border-radius:16px; border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.08); color:#fff; font-size:26px; font-weight:800;
      touch-action:none;
    }

    /* Boutons flottants pliage */
    #toggleHUD, #toggleChat {
      position:fixed; z-index:10; width:44px; height:44px; border-radius:12px; border:1px solid rgba(255,255,255,.2);
      background:rgba(0,0,0,.5); color:#fff; font-weight:800;
    }
    #toggleHUD { right:12px; top:12px; }
    #toggleChat{ left:12px; bottom:12px; }

    /* Ã‰tats pliÃ©s */
    #hud.collapsed    { display:none !important; }
    #chat.collapsed   { display:none !important; }

    /* â€”â€”â€”â€”â€” Responsive â€”â€”â€”â€”â€” */
    @media (hover:none) and (pointer:coarse){
      :root{ --hud-w: 92vw; }
      #mobileUI { display:block; }
      #chat { width: 86vw; left: 7vw; bottom: 10px; max-height: 26vh; }
      #messages { font-size:13px; }
      #hud  { right: 4vw; top: 8px; font-size:12px; padding:8px 10px; gap:6px; }
      #hud .row { gap:6px; }
      #who { max-height: 30vh; overflow:auto; }
      #overlay p { font-size: 13px; }
      input[type="range"]{ width:100px; }
    }
    @media (hover:hover) and (pointer:fine){
      #toggleHUD, #toggleChat { opacity:.7; }
      #toggleHUD:hover, #toggleChat:hover { opacity:1; }
    }

    /* Joystick droit (regard) */
#lookArea{
  position:absolute; right:96px; bottom:14px; width:150px; height:150px; border-radius:50%;
  background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
  pointer-events:auto; touch-action:none; display:none; /* visible que sur mobile */
}
#look{
  position:absolute; left:50%; top:50%; width:72px; height:72px; margin:-36px 0 0 -36px; border-radius:50%;
  background:rgba(180,160,255,.25); border:1px solid rgba(180,160,255,.7); box-shadow:0 0 12px rgba(180,160,255,.5) inset;
  transform: translate(0,0);
}
@media (hover:none) and (pointer:coarse){
  #lookArea{ display:block; }
}
  </style>
</head>
<body>
  <!-- Overlay entrÃ©e -->
  <div id="overlay">
    <h1>Jardin FÃ©erique â€” Salon Global</h1>
    <p>Choisis ton pseudo et ta couleur â€¢ ZQSD = bouger â€¢ Souris = regarder (desktop) â€¢ Joysticks (mobile) â€¢ EntrÃ©e = chat</p>
    <label style="display:block; margin:6px 0;">
      Pseudo : <input id="pseudo" type="text" maxlength="16" placeholder="Ton nom" />
    </label>
    <label style="display:block; margin:6px 0;">
      Couleur : <input id="color" type="color" value="#ff66ff" />
    </label>
    <button id="startBtn">Entrer</button>
  </div>

  <!-- Chat -->
  <div id="chat">
    <ul id="messages"></ul>
    <form id="chatForm">
      <input id="msg" maxlength="200" placeholder="Messageâ€¦" autocomplete="off" />
      <button id="send" type="submit">Envoyer</button>
    </form>
  </div>

  <!-- HUD compact -->
  <div id="hud">
    <div class="row"><strong>ConnectÃ©s :</strong> <span id="onlineCount">1</span></div>
    <div class="row">
      <span><strong>Son :</strong></span>
      <div style="display:flex; gap:6px; align-items:center;">
        <button id="audioToggle" class="btn">OFF</button>
        <input id="audioVol" type="range" min="0" max="1" step="0.01" value="0.2" />
      </div>
    </div>
    <div class="row">
      <span><strong>Herbe :</strong></span>
      <select id="grassQuality">
        <option value="1000">Faible</option>
        <option value="3000" selected>Moyen</option>
        <option value="6000">Ã‰levÃ©</option>
        <option value="10000">Ultra</option>
      </select>
    </div>
    <ul id="who"></ul>
    <div style="opacity:.8; font-size:12px;">E = âœ¨ Aurore â€¢ F = ðŸŒ¸ Fleur â€¢ T = ðŸŒ³ Arbre</div>
  </div>

  <div id="hint" class="hint">Clique dans la scÃ¨ne pour reprendre le contrÃ´le</div>

  <!-- Modal planter fleur -->
  <div id="flowerModal">
    <div class="card">
      <h3 style="margin:0 0 8px; font-size:18px;">Planter une fleur ðŸŒ¸</h3>
      <p style="margin:0 0 10px; opacity:.9; font-size:14px;">
        La fleur sera plantÃ©e <b>pour toujours</b>. Tu peux ajouter un message (optionnel) :
      </p>
      <textarea id="flowerMsg" rows="3" maxlength="140" placeholder="Ton message (140 caractÃ¨res max)"></textarea>
      <div style="display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap;">
        <button id="fmCancel" class="btn">Annuler</button>
        <button id="fmNoMsg" class="btn">Sans message</button>
        <button id="fmWithMsg" class="btn active">Planter</button>
      </div>
    </div>
  </div>

  <!-- MOBILE CONTROLS (deux joysticks + actions) -->
  <div id="mobileUI">
    <div id="stickArea"><div id="stick"></div></div>
    <!-- <div id="lookArea"><div id="lookStick"></div></div> -->
    <div id="lookArea"><div id="look"></div></div>
    <div id="actionArea">
      <button id="btnE" class="act">âœ¨</button>
      <button id="btnF" class="act">ðŸŒ¸</button>
      <button id="btnT" class="act">ðŸŒ³</button>
    </div>
  </div>

  <!-- Boutons pliage -->
  <button id="toggleHUD" aria-label="HUD">â‰¡</button>
  <button id="toggleChat" aria-label="Chat">ðŸ’¬</button>

  <!-- Three.js & Controls en LOCAL -->
  <script src="./three.min.js"></script>
  <script src="./PointerLockControls.js"></script>

  <!-- App + Firebase -->
  <script type="module">
    function startGame() {
  const pseudoEl = document.getElementById('pseudo');
  const colorEl  = document.getElementById('color');
  const overlay  = document.getElementById('overlay');

  const name  = (pseudoEl.value || '').trim().slice(0,16) || 'FÃ©e';
  const color = colorEl.value || '#88e5ff';
  const TWO_DAYS_MS = 2 * 24 * 60 * 60 * 1000;

  // Sauvegarde locale immÃ©diate
  localStorage.setItem('jf_name',  name);
  localStorage.setItem('jf_color', color);

  // Cache lâ€™overlay tout de suite (sans attendre Firebase)
  overlay.style.display = 'none';

  // Flag : si lâ€™auth arrive aprÃ¨s, on poussera name/color
  window.__JF_STARTED__ = true;
  window.__JF_NAME__ = name;
  window.__JF_COLOR__ = color;
}
document.getElementById('overlay').addEventListener('keyup', (e)=>{
  if (e.key === 'Enter') startGame();
});
const startBtn = document.getElementById('startBtn');
// Android peut â€œperdreâ€ le click : on Ã©coute click + touchend
startBtn.addEventListener('click',   (e)=>{ e.preventDefault(); startGame(); });
startBtn.addEventListener('touchend',(e)=>{ e.preventDefault(); startGame(); }, {passive:false});
    /************ Imports Firebase ************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
    import { initializeAppCheck, ReCaptchaV3Provider } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app-check.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged,
      setPersistence, inMemoryPersistence, signOut
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
    import {
      getDatabase, ref, set, update, onValue, onDisconnect,
      push, query, limitToLast, onChildAdded, serverTimestamp, get
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

    /** ðŸ”§ Remplace par TES clÃ©s **/
const firebaseConfig = {
  apiKey: "AIzaSyBUiGGKBssQ_wTrz5uYBkHRKeMk0GNWeFI",
  authDomain: "jardin-feerique.firebaseapp.com",
  databaseURL: "https://jardin-feerique-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "jardin-feerique",
  storageBucket: "jardin-feerique.firebasestorage.app",
  messagingSenderId: "240867851823",
  appId: "1:240867851823:web:43529ae5008fe9dcd910da",
  measurementId: "G-YCZ4XC9PQ1"
};
    const appFB = initializeApp(firebaseConfig);

    // ðŸ›¡ï¸ App Check (reCAPTCHA v3) â€” mets ta "SITE KEY"
    // self.FIREBASE_APPCHECK_DEBUG_TOKEN = true; // (optionnel dev)
    initializeAppCheck(appFB, {
      provider: new ReCaptchaV3Provider('6LcI9LMrAAAAAF6biBHZG20s55PAE24lsPyAwSwZ'), // â† remplace ici
      isTokenAutoRefreshEnabled: true
    });

    const auth = getAuth(appFB);
    const db = getDatabase(appFB);
        const lookAxes = { x: 0, y: 0 };
    let movePointerId = null;  // joystick gauche (dÃ©placement)
    let lookPointerId = null;  // joystick droit (regard)
    let meRef = null;
(async function initFirebaseAndScene(){
    await setPersistence(auth, inMemoryPersistence);
    if (auth.currentUser) await signOut(auth);
    await signInAnonymously(auth);
 onAuthStateChanged(auth, async (user)=>{
    if (!user) return;
    self.uid = user.uid;
    const name  = window.__JF_NAME__  || localStorage.getItem('jf_name')  || ('FÃ©e#'+user.uid.slice(0,4));
    const color = window.__JF_COLOR__ || localStorage.getItem('jf_color') || '#88e5ff';

    self.name = name; self.color = color;

    meRef = ref(db, `/presence/${self.uid}`);
    await set(meRef, { name, color, x:0, z:0, last: Date.now() });
    onDisconnect(meRef).remove();

    // si lâ€™overlay a dÃ©jÃ  Ã©tÃ© fermÃ© par lâ€™utilisateur, pas besoin dâ€™attendre ici
  });

  // ... le reste de ta scÃ¨ne / listeners / onValue etc.
})();

async function serverNowMs(db){
  try {
    const snap = await get(dbRef(db, "/.info/serverTimeOffset"));
    const offset = snap.val() || 0;
    return Date.now() + offset; // ms
  } catch {
    return Date.now(); // fallback
  }
}


function anyStickActive(){ return movePointerId !== null || lookPointerId !== null; }
    /************ Utils ************/
    function sanitizeName(s){ return (s || "").toString().trim().slice(0,16) || "FÃ©e"; }
    function toHexColor(input, fallback="#88e5ff"){
      try { const col = new THREE.Color(input || fallback); return "#"+col.getHexString(); }
      catch(e){ return fallback; }
    }
    const LS_NAME="jf_name", LS_COLOR="jf_color", LS_GRASS="jf_grass";
    const IS_MOBILE = matchMedia('(hover:none) and (pointer:coarse)').matches;

    /************ Audio douce (OFF par dÃ©faut) ************/
    let AudioCtx = null, ctx = null, windGain = null, masterGain = null, ambOn = false;
    function audioInit(){
      if (AudioCtx) return;
      AudioCtx = window.AudioContext || window.webkitAudioContext;
      ctx = new AudioCtx();
      masterGain = ctx.createGain(); masterGain.gain.value = parseFloat(document.getElementById('audioVol').value);
      masterGain.connect(ctx.destination);

      // Vent doux (white noise -> lowpass + LFO)
      const bufferSize = 2 * ctx.sampleRate;
      const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource(); noise.buffer = noiseBuffer; noise.loop = true;
      const lowpass = ctx.createBiquadFilter(); lowpass.type = 'lowpass'; lowpass.frequency.value = 600; lowpass.Q.value = 0.5;
      const lfo = ctx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0.07;
      const lfoGain = ctx.createGain(); lfoGain.gain.value = 120; lfo.connect(lfoGain); lfoGain.connect(lowpass.frequency);
      windGain = ctx.createGain(); windGain.gain.value = 0.0;
      noise.connect(lowpass); lowpass.connect(windGain); windGain.connect(masterGain);
      noise.start(); lfo.start();
    }
    function audioToggle(){
      if (!AudioCtx) audioInit();
      if (ctx.state === 'suspended') ctx.resume();
      ambOn = !ambOn;
      const now = ctx.currentTime;
      windGain.gain.cancelScheduledValues(now);
      windGain.gain.linearRampToValueAtTime(ambOn ? 0.08 : 0.0, now + 0.3);
      const b = document.getElementById('audioToggle');
      b.textContent = ambOn ? 'ON' : 'OFF'; b.classList.toggle('active', ambOn);
    }
    function setMasterVolume(v){ if (masterGain) masterGain.gain.value = v; }
    function tint(freq=1200, dur=0.22) {
      if (!ctx) return;
      const o = ctx.createOscillator(); o.type='triangle'; o.frequency.value=freq;
      const g = ctx.createGain(); g.gain.value=0.0; o.connect(g); g.connect(masterGain);
      const now = ctx.currentTime; g.gain.linearRampToValueAtTime(0.07, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
      o.start(now); o.stop(now+dur+0.05);
    }
    const audioBtn = document.getElementById('audioToggle');
    const audioVol = document.getElementById('audioVol');
    audioBtn.addEventListener('click', ()=>{ audioToggle(); if (ambOn) tint(1500, 0.15); });
    audioVol.addEventListener('input', ()=> setMasterVolume(parseFloat(audioVol.value)));

    /************ THREE scÃ¨ne ************/
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060a);
    scene.fog = new THREE.FogExp2(0x0a1022, 0.009);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1200);
    camera.position.set(0, 1.6, 6);
    camera.rotation.order = 'YXZ';
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio( IS_MOBILE ? Math.min(devicePixelRatio, 1.5) : Math.min(devicePixelRatio, 2) );
    renderer.domElement.style.touchAction = 'none';
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    const hint = document.getElementById('hint');
    controls.addEventListener('unlock', ()=>{ if (!IS_MOBILE) hint.style.display = 'block'; });
    controls.addEventListener('lock',   ()=>{ if (!IS_MOBILE) hint.style.display = 'none'; });
    renderer.domElement.addEventListener('click', ()=>{ if (!IS_MOBILE && !controls.isLocked) controls.lock(); });

    // LumiÃ¨res
    scene.add(new THREE.HemisphereLight(0x7dd3fc, 0x1e293b, 0.9));
    const sun = new THREE.DirectionalLight(0xffffff, 0.15); sun.position.set(30,60,20); scene.add(sun);

    /************ Terrain ************/
    function heightFn(x,z){ return 0.6*Math.sin(x*0.04)*Math.cos(z*0.035) + 0.25*Math.sin((x+z)*0.06); }
    function noise2(x, z){ return Math.sin(x*0.11 + Math.cos(z*0.07)*2.1) * 0.5 + Math.cos(z*0.13 + Math.sin(x*0.05)*1.7) * 0.5; }

    const SIZE = 280, SEG = 140;
    const terrainGeo = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG);
    { // push Z, color
      const pos = terrainGeo.attributes.position;
      const colors = new Float32Array(pos.count * 3);
      const c1 = new THREE.Color(0x104f33), c2 = new THREE.Color(0x2e8b57);
      for (let i=0;i<pos.count;i++){
        const x = pos.getX(i), z = pos.getY(i), h = heightFn(x, z);
        pos.setZ(i, h);
        const shade = THREE.MathUtils.clamp(0.55 + h*0.08 + noise2(x,z)*0.08, 0.35, 0.9);
        const col = c1.clone().lerp(c2, shade);
        colors[i*3+0] = col.r; colors[i*3+1] = col.g; colors[i*3+2] = col.b;
      }
      terrainGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      pos.needsUpdate = true;
    }
    terrainGeo.rotateX(-Math.PI/2); terrainGeo.computeVertexNormals();
    const ground = new THREE.Mesh(terrainGeo, new THREE.MeshStandardMaterial({ vertexColors:true, roughness:0.95, metalness:0.0 }));
    ground.receiveShadow = true; scene.add(ground);

    /************ Herbe procÃ©durale ************/
    const grassSelect = document.getElementById('grassQuality');
    const savedGrass = localStorage.getItem(LS_GRASS);
    if (savedGrass && grassSelect.querySelector(`option[value="${savedGrass}"]`)) grassSelect.value = savedGrass;
    else if (IS_MOBILE && !savedGrass){ grassSelect.value = '3000'; }

    let grass = null;
    function buildGrass(bladeCount){
      if (grass?.dispose) grass.dispose();
      const bladeGeo = new THREE.PlaneGeometry(0.06, 0.55, 1, 2);
      bladeGeo.translate(0, 0.275, 0);
      const bladeMat = new THREE.MeshStandardMaterial({ color: 0x2ea043, side: THREE.DoubleSide, roughness: 0.95, metalness: 0.0 });
      const inst = new THREE.InstancedMesh(bladeGeo, bladeMat, bladeCount);
      inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage); scene.add(inst);

      const dummy = new THREE.Object3D();
      const phases = new Float32Array(bladeCount), px = new Float32Array(bladeCount), pz = new Float32Array(bladeCount), baseY = new Float32Array(bladeCount);
      const R = 95;
      for (let i=0;i<bladeCount;i++){
        const a = Math.random()*Math.PI*2, r = Math.sqrt(Math.random()) * R;
        const x = Math.cos(a)*r, z = Math.sin(a)*r, y = heightFn(x,z) + 0.02;
        px[i]=x; pz[i]=z; baseY[i]=y; phases[i] = Math.random()*Math.PI*2;
        dummy.position.set(x,y,z); dummy.rotation.set(0, a, 0); dummy.scale.set(1, 0.8 + Math.random()*0.5, 1); dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);
      }
      inst.instanceMatrix.needsUpdate = true;

      const swayDummy = new THREE.Object3D();
      function tick(t){
        const wind = 0.15 + 0.08*Math.sin(t*0.6);
        for (let i=0;i<bladeCount;i++){
          const sway = 0.15 * Math.sin(t*1.5 + phases[i] + px[i]*0.04 + pz[i]*0.04) * wind;
          swayDummy.position.set(px[i], baseY[i], pz[i]);
          swayDummy.rotation.set(sway, 0, 0);
          swayDummy.scale.set(1, 0.8 + Math.abs(Math.sin(phases[i]))*0.5, 1);
          swayDummy.updateMatrix();
          inst.setMatrixAt(i, swayDummy.matrix);
        }
        inst.instanceMatrix.needsUpdate = true;
      }
      function dispose(){ scene.remove(inst); inst.geometry?.dispose?.(); inst.material?.dispose?.(); }
      return { tick, dispose };
    }
    grass = buildGrass(parseInt(grassSelect.value,10));
    grassSelect.addEventListener('change', ()=>{ const count = parseInt(grassSelect.value,10); localStorage.setItem(LS_GRASS, String(count)); grass = buildGrass(count); tint(1700,0.15); });

    /************ Ã‰toiles + Lucioles (visibles) ************/
    let stars = null;
    function buildStars(count = IS_MOBILE ? 1000 : 1400) {
      if (stars) { scene.remove(stars); stars.geometry?.dispose?.(); stars.material?.dispose?.(); stars = null; }
      const starGeo = new THREE.BufferGeometry();
      const starPos = new Float32Array(count * 3);
      for (let i = 0; i < starPos.length; i += 3) {
        starPos[i]   = (Math.random() - 0.5) * 1200;
        starPos[i+1] = Math.random() * 600 + 160;
        starPos[i+2] = (Math.random() - 0.5) * 1200;
      }
      starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
      const starMat = new THREE.PointsMaterial({ size: 1.6, transparent: true, opacity: 0.95, depthWrite: false, blending: THREE.AdditiveBlending, color: 0xffffff, fog: false });
      stars = new THREE.Points(starGeo, starMat); scene.add(stars);
    }
    buildStars();

    let fireflies = null;
    function buildFireflies(count = IS_MOBILE ? 220 : 280, radius = 180) {
      if (fireflies) { scene.remove(fireflies); fireflies.geometry?.dispose?.(); fireflies.material?.dispose?.(); fireflies = null; }
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const vel = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2, r = Math.sqrt(Math.random()) * radius;
        const x = Math.cos(a) * r, z = Math.sin(a) * r;
        pos[i*3+0] = x; pos[i*3+2] = z; pos[i*3+1] = heightFn(x, z) + 0.8 + Math.random() * 3;
        vel[i*3+0] = (Math.random() - 0.5) * 0.06; vel[i*3+1] = (Math.random() - 0.5) * 0.03; vel[i*3+2] = (Math.random() - 0.5) * 0.06;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      const mat = new THREE.PointsMaterial({ size: 0.10, transparent: true, opacity: 1.0, depthWrite: false, blending: THREE.AdditiveBlending, color: 0xfff7b1, fog: false });
      fireflies = new THREE.Points(geo, mat); fireflies.userData = { vel, radius }; scene.add(fireflies);
    }
    function tickFireflies(pp, dt){
      if (!pp) return;
      const p = pp.geometry.attributes.position.array, v = pp.userData.vel;
      for (let i=0;i<v.length;i+=3){
        v[i+0] += (Math.random()-0.5)*0.002; v[i+1] += (Math.random()-0.5)*0.002; v[i+2] += (Math.random()-0.5)*0.002;
        p[i+0] += v[i+0]*dt*60; p[i+1] += v[i+1]*dt*60; p[i+2] += v[i+2]*dt*60;
        const x = p[i+0], z = p[i+2], h = heightFn(x, z) + 0.5;
        if (p[i+1] < h) p[i+1] = h; if (p[i+1] > h + 4.0) p[i+1] = h + 4.0;
      }
      pp.geometry.attributes.position.needsUpdate = true;
    }
    buildFireflies();

    /************ Overlay pseudo/couleur ************/
    const pseudoEl = document.getElementById('pseudo'), colorEl  = document.getElementById('color');
    const savedName  = localStorage.getItem(LS_NAME),  savedColor = localStorage.getItem(LS_COLOR);
    if (savedName)  pseudoEl.value = savedName; if (savedColor) colorEl.value  = savedColor;

    /************ Saisie / Ã©tats ************/
    function isTyping() {
      const el = document.activeElement;
      const modalOpen = document.getElementById('flowerModal')?.style.display === 'grid';
      const typing = el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable);
      return modalOpen || typing;
    }

    /************ DÃ©placements analogiques ************/
    const velocity = new THREE.Vector3(), direction = new THREE.Vector3();
    // Axes analogiques: -1..1 (x = strafe, y = forward)
    const axes = { x: 0, y: 0 };

    addEventListener('keydown', (e)=>{
      if (isTyping()) return;
      if (e.code === 'Enter') { e.preventDefault(); document.getElementById('msg').focus(); return; }
      if (e.code === 'KeyW' || e.code === 'KeyZ') { e.preventDefault(); axes.y = -1; }
      if (e.code === 'KeyS')                       { e.preventDefault(); axes.y =  1; }
      if (e.code === 'KeyA' || e.code === 'KeyQ') { e.preventDefault(); axes.x = -1; }
      if (e.code === 'KeyD')                       { e.preventDefault(); axes.x =  1; }
      if (e.code === 'KeyE') { e.preventDefault(); castAurora(); tint(1300,0.12); }
      if (e.code === 'KeyF') { e.preventDefault(); if (controls.isLocked) controls.unlock(); plantFlower(); }
      if (e.code === 'KeyT') { e.preventDefault(); if (controls.isLocked) controls.unlock(); plantTree(); }
    });
    addEventListener('keyup', (e)=>{
      if (isTyping()) return;
      if (e.code === 'KeyW' || e.code === 'KeyZ') { if (axes.y < 0) axes.y = 0; }
      if (e.code === 'KeyS')                       { if (axes.y > 0) axes.y = 0; }
      if (e.code === 'KeyA' || e.code === 'KeyQ') { if (axes.x < 0) axes.x = 0; }
      if (e.code === 'KeyD')                       { if (axes.x > 0) axes.x = 0; }
    });

    // EmpÃªcher les touches de sortir des inputs
    const msgInput = document.getElementById('msg');
    ['keydown','keyup','keypress'].forEach(ev=> msgInput.addEventListener(ev, (e)=> e.stopPropagation()));
    ;[pseudoEl, colorEl].forEach(el => ['keydown','keyup','keypress'].forEach(ev=> el.addEventListener(ev, (e)=> e.stopPropagation())));
    ;['flowerMsg','fmCancel','fmNoMsg','fmWithMsg'].forEach(id=>{
      const el = document.getElementById(id); if (!el) return;
      ['keydown','keyup','keypress','click'].forEach(ev=> el.addEventListener(ev, (e)=> e.stopPropagation()));
    });

    /************ Joystick gauche (mouvement) ************/
    const stickArea = document.getElementById('stickArea'), stick = document.getElementById('stick');
    let stickActive=false, sx=0, sy=0;
    function setMoveFromStick(x, y){
      const r = Math.hypot(x,y);
      const DZ = 0.20; // deadzone
      const k = r <= DZ ? 0 : ( (r - DZ) / (1 - DZ) );
      const curve = Math.pow(k, 1.7);
      const nx = r ? (x / r) * curve : 0;
      const ny = r ? (y / r) * curve : 0;
      axes.x = nx;   // gauche(-) / droite(+)
      axes.y = -ny;   // bas(+) / haut(-) â†’ inversÃ© dans animate()
    }
    if (IS_MOBILE){
      const R = 75; // rayon joystick
stickArea.addEventListener('pointerdown', (e)=>{
  if (e.pointerType !== 'touch') return;
  if (movePointerId !== null) return;     // dÃ©jÃ  utilisÃ©
  movePointerId = e.pointerId;
  stickArea.setPointerCapture(movePointerId);
  e.preventDefault();

  const rect = stickArea.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  const dx = e.clientX - cx, dy = e.clientY - cy;
  const dist = Math.min(R, Math.hypot(dx,dy));
  const ang  = Math.atan2(dy, dx);
  const px = Math.cos(ang)*dist, py = Math.sin(ang)*dist;
  stick.style.transform = `translate(${px}px, ${py}px)`;
  setMoveFromStick(px/R, py/R);
}, { passive:false });

stickArea.addEventListener('pointermove', (e)=>{
  if (e.pointerId !== movePointerId) return;
  e.preventDefault();
  const rect = stickArea.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  const dx = e.clientX - cx, dy = e.clientY - cy;
  const dist = Math.min(R, Math.hypot(dx,dy));
  const ang  = Math.atan2(dy, dx);
  const px = Math.cos(ang)*dist, py = Math.sin(ang)*dist;
  stick.style.transform = `translate(${px}px, ${py}px)`;
  setMoveFromStick(px/R, py/R);
}, { passive:false });

function resetMoveStick(){
  stick.style.transform = 'translate(0,0)';
  setMoveFromStick(0,0);
}

stickArea.addEventListener('pointerup', (e)=>{
  if (e.pointerId !== movePointerId) return;
  stickArea.releasePointerCapture(movePointerId);
  movePointerId = null;
  resetMoveStick();
});

stickArea.addEventListener('pointercancel', (e)=>{
  if (e.pointerId !== movePointerId) return;
  movePointerId = null;
  resetMoveStick();
});
    }

    /************ Joystick droit (camÃ©ra) ************/
    const lookArea = document.getElementById('lookArea');
const lookKnob = document.getElementById('look');
let lookActive = false;

function setLookFromStick(x, y){
  // x,y dans [-1..1]
  // Deadzone + courbe douce (plus stable)
  const r = Math.hypot(x,y);
  const DZ = 0.16;
  const k = r <= DZ ? 0 : ( (r - DZ) / (1 - DZ) ); // 0..1
  const curve = Math.pow(k, 1.4);
  const nx = (r ? x/r : 0) * curve;
  const ny = (r ? y/r : 0) * curve;

  // Convention : droite positive => regarde Ã  droite ; haut positif => regarde vers le haut
  lookAxes.x = nx;        // yaw
  lookAxes.y = -ny;       // pitch (vers le haut si on pousse le stick vers le haut)
}

if (IS_MOBILE){
const Rlook = 75;
lookArea.addEventListener('pointerdown', (e)=>{
  if (anyStickActive()) return;
  if (e.pointerType !== 'touch') return;
  if (lookPointerId !== null) return;
  lookPointerId = e.pointerId;
  lookArea.setPointerCapture(lookPointerId);
  e.preventDefault();

  const rect = lookArea.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  const dx = e.clientX - cx, dy = e.clientY - cy;
  const dist = Math.min(Rlook, Math.hypot(dx,dy));
  const ang  = Math.atan2(dy, dx);
  const px = Math.cos(ang)*dist, py = Math.sin(ang)*dist;
  look.style.transform = `translate(${px}px, ${py}px)`;
  setLookFromStick(px/Rlook, py/Rlook);
}, { passive:false });

lookArea.addEventListener('pointermove', (e)=>{
  if (e.pointerId !== lookPointerId) return;
  e.preventDefault();
  const rect = lookArea.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  const dx = e.clientX - cx, dy = e.clientY - cy;
  const dist = Math.min(Rlook, Math.hypot(dx,dy));
  const ang  = Math.atan2(dy, dx);
  const px = Math.cos(ang)*dist, py = Math.sin(ang)*dist;
  look.style.transform = `translate(${px}px, ${py}px)`;
  setLookFromStick(px/Rlook, py/Rlook);
}, { passive:false });

function resetLookStick(){
  look.style.transform = 'translate(0,0)';
  lookAxes.x = 0; lookAxes.y = 0;
}

lookArea.addEventListener('pointerup', (e)=>{
  if (e.pointerId !== lookPointerId) return;
  lookArea.releasePointerCapture(lookPointerId);
  lookPointerId = null;
  resetLookStick();
});

lookArea.addEventListener('pointercancel', (e)=>{
  if (e.pointerId !== lookPointerId) return;
  lookPointerId = null;
  resetLookStick();
});
}

    /************ Boutons actions (mobile) ************/
    if (IS_MOBILE){
      document.getElementById('btnE').addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); castAurora(); });
      document.getElementById('btnF').addEventListener('click', async (e)=>{ e.preventDefault(); e.stopPropagation(); await plantFlower(); });
      document.getElementById('btnT').addEventListener('click', async (e)=>{ e.preventDefault(); e.stopPropagation(); await plantTree(); });
    }

    /************ Toggles HUD/Chat ************/
    const LS_HUD = 'jf_hud_open', LS_CHAT = 'jf_chat_open';
    const hud = document.getElementById('hud');
    const chatBox = document.getElementById('chat');
    const btnHUD = document.getElementById('toggleHUD');
    const btnChat = document.getElementById('toggleChat');

    function setHUD(open){
      hud.classList.toggle('collapsed', !open);
      localStorage.setItem(LS_HUD, open ? '1' : '0');
      btnHUD.textContent = open ? 'Ã—' : 'â‰¡';
    }
    function setChat(open){
      chatBox.classList.toggle('collapsed', !open);
      localStorage.setItem(LS_CHAT, open ? '1' : '0');
      btnChat.textContent = open ? 'Ã—' : 'ðŸ’¬';
    }
    btnHUD.addEventListener('click', (e)=>{ e.stopPropagation(); setHUD(hud.classList.contains('collapsed')); });
    btnChat.addEventListener('click', (e)=>{ e.stopPropagation(); setChat(chatBox.classList.contains('collapsed')); });
    const hudPref  = localStorage.getItem(LS_HUD);
    const chatPref = localStorage.getItem(LS_CHAT);
    const defaultOpenHUD  = IS_MOBILE ? false : true;
    const defaultOpenChat = IS_MOBILE ? false : true;
    setHUD(hudPref  === null ? defaultOpenHUD  : hudPref  === '1');
    setChat(chatPref === null ? defaultOpenChat : chatPref === '1');

    /************ Chat ************/
    const messagesList = document.getElementById('messages');
    const chatForm = document.getElementById('chatForm');
    const chatRef = ref(db, '/chat/global');
    onChildAdded(query(chatRef, limitToLast(50)), snap=>{
      const m = snap.val(); const li = document.createElement('li'); li.textContent = `[${m.name}] ${m.text}`;
      messagesList.appendChild(li); messagesList.scrollTop = messagesList.scrollHeight;
    });
    chatForm.addEventListener('submit', (e)=>{
      e.preventDefault(); const text = (msgInput.value || "").trim(); if (!text) return;
      push(chatRef, { name: self.name || "FÃ©e", text, ts: Date.now() }); msgInput.value = "";
      if (IS_MOBILE) setChat(false);
    });

    /************ Avatars + labels ************/
    const avatars = new Map();
    function roundRect(ctx, x, y, w, h, r) { r = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r); ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r); ctx.arcTo(x,   y,   x+w, y,   r); ctx.closePath(); }
function makeLabelSprite(text, color, maxW = 240, fs = 28, scale = 0.012) {
  // Cap le DPR pour Ã©viter des textures gÃ©antes
  const dpr = Math.min(window.devicePixelRatio || 1, 2);

  // Canvas & contexte
  const cvs = document.createElement('canvas');
  const ctx = cvs.getContext('2d');

  // Mesures en "CSS px" (avant scale)
  const padX = 10, padY = 8;
  ctx.font = `400 ${fs}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;

  // Wrap du texte
  const words = String(text || '').split(/\s+/).filter(Boolean);
  const lines = [];
  let line = '';
  for (const w of words.length ? words : [' ']) {
    const test = line ? line + ' ' + w : w;
    if (ctx.measureText(test).width + padX * 2 > maxW) {
      if (line) lines.push(line);
      line = w;
    } else {
      line = test;
    }
  }
  if (line) lines.push(line);

  // Dimensions en CSS px
  const cssW = Math.ceil(Math.max(64, Math.max(...lines.map(l => ctx.measureText(l).width)) + padX * 2));
  const lineH = fs + 4;
  const cssH = Math.ceil(Math.max(32, lineH * lines.length + padY * 2));

  // Dimensions rÃ©elles du canvas en px physiques
  cvs.width  = Math.ceil(cssW * dpr);
  cvs.height = Math.ceil(cssH * dpr);

  // Recalage du contexte pour dessiner en unitÃ©s CSS px
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.font = `400 ${fs}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
  ctx.textBaseline = 'middle';

  // BG arrondi
  roundRect(ctx, 0, 0, cssW, cssH, 10);
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fill();

  // Couleur du texte
  const col = (color?.getStyle ? color.getStyle() : (typeof color === 'string' ? color : '#ffffff'));
  ctx.fillStyle = col;

  // Texte
  lines.forEach((l, i) => {
    ctx.fillText(l, padX, Math.floor(padY + lineH * i + lineH / 2));
  });

  // Texture & sprite
  const tex = new THREE.CanvasTexture(cvs);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, depthWrite: false });
  const spr = new THREE.Sprite(mat);

  // âš ï¸ Ã‰chelle basÃ©e sur la taille CSS, pas sur canvas.width
  spr.scale.set(cssW * scale, cssH * scale, 1);
  spr.renderOrder = 999;

  return spr;
}
    function spawnAvatar(uid, data){
      if (avatars.has(uid)) return;
      const name = (data?.name ?? ("FÃ©e#" + uid.slice(0,4)));
      const color = new THREE.Color( toHexColor(data?.color, "#ff0077") );
      const group = new THREE.Group(); const radius = 1.1;
      const body = new THREE.Mesh(new THREE.SphereGeometry(radius, 22, 18), new THREE.MeshStandardMaterial({ color, emissive: color.clone().multiplyScalar(0.25) }));
      body.position.set(0, radius, 0);
      const label = makeLabelSprite(name, color, 220, 26, 0.0115); label.position.set(0, radius + 0.8, 0);
      const halo = new THREE.PointLight(color, 1.0, 8, 2.0); halo.position.set(0, radius, 0);
      group.add(body, label, halo); scene.add(group);
      avatars.set(uid, { group, body, label, halo, target: { x:0, z:0 }, color, name });
    }
    function despawnAvatar(uid){ const a = avatars.get(uid); if (!a) return; scene.remove(a.group); avatars.delete(uid); }
    function updateAvatars(everyone){
      for (const [uid, data] of Object.entries(everyone)) {
        if (!avatars.has(uid)) spawnAvatar(uid, data);
        const a = avatars.get(uid);
        const x = Number.isFinite(data?.x) ? data.x : a.group.position.x;
        const z = Number.isFinite(data?.z) ? data.z : a.group.position.z;
        a.target = { x, z };
        const newName = data?.name ?? a.name;
        const newColor = new THREE.Color( toHexColor(data?.color, "#ff0077") );
        if (newName !== a.name || newColor.getHex() !== a.color.getHex()){
          a.name = newName; a.color = newColor;
          a.group.remove(a.label);
          a.label = makeLabelSprite(a.name, a.color, 220, 26, 0.0115); a.label.position.set(0, 1.1 + 0.8, 0); a.group.add(a.label);
          a.halo.color = a.color; a.body.material.color = a.color; a.body.material.emissive = a.color.clone().multiplyScalar(0.25);
        }
      }
      for (const uid of Array.from(avatars.keys())) if (!everyone[uid]) despawnAvatar(uid);
    }

    /************ FX ************/
    const liveFx = new Set();
    function spawnRing(x,z,color="#88e5ff"){
      const y = heightFn(x,z) + 0.02;
      const ring = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.42, 48), new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.9, side:THREE.DoubleSide, depthWrite:false }));
      ring.rotation.x = -Math.PI/2; ring.position.set(x, y, z); ring.userData = { t:0 };
      ring.userData.tick = (dt)=>{ const u=ring.userData; u.t+=dt; const s=1+u.t*2.2; ring.scale.set(s,s,1); ring.material.opacity=Math.max(0,0.9-u.t*0.8); if (u.t>1.4){ scene.remove(ring); ring.geometry.dispose(); ring.material.dispose(); } };
      scene.add(ring); return ring;
    }
    function spawnSparks(x,z,color="#88e5ff"){
      const y0 = heightFn(x,z) + 1.2, count = 60;
      const geo = new THREE.BufferGeometry(), pos = new Float32Array(count*3), vel = new Float32Array(count*3);
      for (let i=0;i<count;i++){ pos[i*3+0]=x; pos[i*3+1]=y0; pos[i*3+2]=z; const a=Math.random()*Math.PI*2, s=0.35+Math.random()*0.9; vel[i*3+0]=Math.cos(a)*s; vel[i*3+1]=0.9+Math.random()*1.1; vel[i*3+2]=Math.sin(a)*s; }
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      const pp = new THREE.Points(geo, new THREE.PointsMaterial({ size:0.07, color, transparent:true, opacity:1.0, depthWrite:false }));
      pp.userData = { vel, life: 1.1 }; pp.userData.tick = (dt)=>{ const p=pp.geometry.attributes.position.array, v=pp.userData.vel; pp.userData.life-=dt;
        for (let i=0;i<v.length;i+=3){ v[i+1]-=0.98*dt; p[i+0]+=v[i+0]*dt; p[i+1]+=v[i+1]*dt; p[i+2]+=v[i+2]*dt; }
        pp.material.opacity = Math.max(0, pp.userData.life/1.1); pp.geometry.attributes.position.needsUpdate=true;
        if (pp.userData.life<=0){ scene.remove(pp); pp.geometry.dispose(); pp.material.dispose(); } };
      scene.add(pp); return pp;
    }

    /************ Fleurs ************/
    function rng(seed){ return ()=> (seed = (seed*1664525 + 1013904223) >>> 0) / 4294967296; }
    function lerp(a,b,t){ return a+(b-a)*t; }
    function clamp01(x){ return Math.min(1, Math.max(0, x)); }
    function harmonizeColor(baseHex, r01){
      const c = new THREE.Color(baseHex); const hsl = { h:0,s:0,l:0 }; c.getHSL(hsl);
      const petal = new THREE.Color().setHSL(hsl.h + lerp(-0.03,0.03,r01()), clamp01(hsl.s*0.8 + 0.15), clamp01(lerp(0.55,0.75,r01())));
      const pistil = new THREE.Color().setHSL(lerp(0.10,0.16,r01()), lerp(0.6,0.9,r01()), lerp(0.5,0.7,r01()));
      const stem = new THREE.Color().setHSL(lerp(0.30,0.38,r01()), lerp(0.35,0.6,r01()), lerp(0.25,0.45,r01()));
      return { petal, pistil, stem };
    }
    function petalGeometry(type, r01, radius, length, thickness){
      const t = type, geo = new THREE.PlaneGeometry(radius, length, 1, 8), posG = geo.attributes.position;
      for (let i=0;i<posG.count;i++){ const y=posG.getY(i), bend=Math.sin((y/length)*Math.PI)*thickness, x=posG.getX(i);
        posG.setX(i, x * (t===1 ? 1.15 : t===2 ? 0.85 : 1.0)); posG.setZ(i, bend * (t===2 ? 1.4 : 1.0)); }
      posG.needsUpdate = true; geo.computeVertexNormals(); return geo;
    }
    function makeLabelSpriteFlower(name, ts, color, msg){
      const date = new Date(ts || Date.now()), dd=String(date.getDate()).padStart(2,'0'), mm=String(date.getMonth()+1).padStart(2,'0'), yyyy=date.getFullYear();
      let text = `${name} â€¢ ${dd}/${mm}/${yyyy}`; if (msg && (msg=msg.trim())) text += " â€” " + msg.slice(0,140);
      return makeLabelSprite(text, color, 260, 16, 0.0105);
    }
    function spawnFlowerFancy(f, key){
      const seed = ((f.seed ?? f.ts ?? 1) ^ (key ? key.length*2654435761 : 0)) >>> 0, rnd = rng(seed);
      const variant = Math.floor(rnd()*3), petals = 5 + Math.floor(rnd()*3);
      const radius = lerp(0.16, 0.26, rnd()), length = lerp(0.35, 0.52, rnd()), thickness = lerp(0.06, 0.1, rnd());
      const height = lerp(0.55, 0.8, rnd()), lean = lerp(-0.22, 0.22, rnd());
      const colors = harmonizeColor(f.color || "#a0ffcc", rnd);
      const x=f.x||0, z=f.z||0, y=heightFn(x,z); const g = new THREE.Group(); g.position.set(x, y, z);
      const stemMat = new THREE.MeshStandardMaterial({ color: colors.stem });
      const stem = new THREE.Group(); for (let i=0;i<3;i++){ const seg=new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.045, height/3, 10), stemMat); seg.position.y=(i+0.5)*(height/3); stem.add(seg); }
      stem.rotation.z = lean; g.add(stem);
      const leafGeo = new THREE.PlaneGeometry(0.26, 0.16, 1, 4), leafMat = new THREE.MeshStandardMaterial({ color: colors.stem, side: THREE.DoubleSide });
      const leaf1 = new THREE.Mesh(leafGeo, leafMat), leaf2 = new THREE.Mesh(leafGeo, leafMat);
      leaf1.position.set(0.08, height*0.45, 0); leaf1.rotation.set(0, Math.PI*0.15, -Math.PI*0.35);
      leaf2.position.set(-0.08, height*0.3, 0);  leaf2.rotation.set(0, -Math.PI*0.15, Math.PI*0.35);
      g.add(leaf1, leaf2);
      const pistil = new THREE.Mesh(new THREE.SphereGeometry(0.085, 14, 10), new THREE.MeshStandardMaterial({ color: colors.pistil, emissive: colors.pistil.clone().multiplyScalar(0.22) }));
      pistil.position.y = height + length*0.5; g.add(pistil);
      const petalsGroup = new THREE.Group(), petMat = new THREE.MeshStandardMaterial({ color: colors.petal, emissive: colors.petal.clone().multiplyScalar(0.1), side: THREE.DoubleSide });
      const petGeo = petalGeometry(variant, rnd, radius, length, thickness);
      for (let i=0;i<petals;i++){ const p = new THREE.Mesh(petGeo, petMat); const a=(i/petals)*Math.PI*2;
        p.position.set(Math.cos(a)*radius*0.15, height + length*0.35, Math.sin(a)*radius*0.15);
        p.rotation.y = a; p.rotation.x = -Math.PI/2; p.rotation.z = lerp(-0.08,0.08,rnd()); petalsGroup.add(p); }
      g.add(petalsGroup);
      const label = makeLabelSpriteFlower(f.name || ("FÃ©e#" + String(f.uid||"").slice(0,4)), f.ts || Date.now(), new THREE.Color(colors.petal), f.msg || "");
      label.position.set(0, height + length + 0.7, 0); g.add(label);
      scene.add(g); return g;
    }

    /************ Modal Fleur ************/
    function askFlowerMessage(){
      return new Promise((resolve)=>{
        const modal = document.getElementById('flowerModal');
        const ta    = document.getElementById('flowerMsg');
        const bNo   = document.getElementById('fmNoMsg');
        const bYes  = document.getElementById('fmWithMsg');
        const bCancel = document.getElementById('fmCancel');
        const cleanup = ()=>{ modal.style.display = 'none'; bNo.onclick = bYes.onclick = bCancel.onclick = null; };
        modal.style.display = 'grid'; ta.value = ""; ta.focus();
        bCancel.onclick = ()=>{ cleanup(); resolve({ proceed:false, msg:null }); };
        bNo.onclick     = ()=>{ cleanup(); resolve({ proceed:true, msg:null }); };
        bYes.onclick    = ()=>{ cleanup(); resolve({ proceed:true, msg: (ta.value||"").trim().slice(0,140) || null }); };
      });
    }

    /************ Events & Garden ************/
    const spellsRef  = ref(db, '/events/spells');
    const gardenRef  = ref(db, '/garden');
    const treesRef = ref(db, '/trees');

    const TREE_GROW_MS = 2 * 24 * 60 * 60 * 1000; // 2 jours
    //window.GROW_DEBUG_MULT = 1;
//function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function smoothstep(t){ return t*t*(3-2*t); } // interpolation douce 0..1
    function castAurora(){
      const p = controls.getObject().position;
      const colorHex = toHexColor(self.color, "#88e5ff");
      push(spellsRef, { uid:self.uid, x:+p.x.toFixed(2), z:+p.z.toFixed(2), color:colorHex, ts: Date.now() });
    }
async function plantTree(){
  await ensureReady();

  const now = await serverNowMs(db); // â† renvoie un nombre serveur
  const p = controls.getObject().position;
  const uid = auth.currentUser.uid;

    // â›”ï¸ VÃ©rif cÃ´tÃ© client : limite 1 arbre / 2 jours
  const lastTreeSnap = await get(ref(db, `/meta/lastTree/${uid}`));
  const lastTs = lastTreeSnap.val() || 0;
  const remain = 172800000 - (now - lastTs);      // 2 jours en ms
  if (remain > 0) {
    const h = Math.floor(remain / 3600000);
    const m = Math.floor((remain % 3600000) / 60000);
    alert(`Vous pourrez planter un nouvel arbre dans ${h}h ${m}min`);
    return;                                       // on sort : pas dâ€™Ã©criture
  }
  const id  = push(ref(db, "/trees")).key;

  const tree = {
    uid,
    name: (self.name || ("FÃ©e#" + uid.slice(0,4))).toString().slice(0,16),
    x: +p.x.toFixed(2),
    z: +p.z.toFixed(2),
    color: toHexColor(self.color, "#88e5ff"),
    ts: now,  // â† nombre serveur
    seed: Math.floor(Math.random()*1e9)
  };

const updates = {};
updates[`/trees/${id}`] = tree;
updates[`/meta/lastTree/${uid}`] = now;
  await update(ref(db), updates);
  //await update(ref(db, "/"), updates);
}
// Attend que Firebase Auth soit prÃªt (Ã©vite les permission_denied)
async function ensureReady(){
  if (!auth.currentUser) {
    await new Promise((resolve) => {
      const unsub = onAuthStateChanged(auth, (u)=>{
        if (u) { unsub(); resolve(); }
      });
    });
  }
}

async function plantFlower(){
  const { proceed, msg } = await askFlowerMessage();
  if (!proceed) return;

  await ensureReady(); // ta fonction d'attente d'auth

  const p = controls.getObject().position;
  const uid = auth.currentUser.uid;

  const payload = {
    uid,
    name: (self.name || ("FÃ©e#" + uid.slice(0,4))).toString().slice(0,16),
    x: +p.x.toFixed(2),
    z: +p.z.toFixed(2),
    color: toHexColor(self.color, "#a0ffcc"),
    ts: serverTimestamp(),                // â¬…ï¸ horloge serveur RTDB
    seed: Math.floor(Math.random()*1e9)
  };
  if (msg && msg.trim()) payload.msg = msg.trim().slice(0,140);

  await push(ref(db, "/garden"), payload);
}
    onChildAdded(query(spellsRef, limitToLast(40)), snap=>{
      const ev = snap.val(); if (!ev) return; if (Date.now() - (ev.ts || 0) > 15_000) return;
      const color = ev.color || "#88e5ff"; const ring = spawnRing(ev.x, ev.z, color); const sparks = spawnSparks(ev.x, ev.z, color);
      liveFx.add(ring); liveFx.add(sparks);
    });
    const flowers = new Map();
    onChildAdded(query(gardenRef, limitToLast(2000)), snap=>{
      const f = snap.val(); if (!f) return; flowers.set(snap.key, f); spawnFlowerFancy(f, snap.key);
    });

    //function rng(seed){ return ()=> (seed = (seed*1664525 + 1013904223) >>> 0) / 4294967296; }
function makeTreeMesh(seed, baseColor = "#88e5ff"){
  const r = rng(seed || 1);

  // --- Tronc + canopÃ©e (taille finale) ---
  const trunkH   = 1.2 + r()*0.6;
  const trunkTop = 0.08 + r()*0.04;
  const trunkBot = 0.12 + r()*0.05;
  const trunkGeo = new THREE.CylinderGeometry(trunkTop, trunkBot, trunkH, 8);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5b3a1c, roughness: 0.9 });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.y = trunkH/2;

  const canopyR   = 0.9 + r()*0.6;
  const canopyGeo = new THREE.IcosahedronGeometry(canopyR, 1);
  const leafCol   = new THREE.Color(baseColor);
  const canopyMat = new THREE.MeshStandardMaterial({ color: leafCol, roughness: 0.8, metalness: 0.0 });
  const canopy = new THREE.Mesh(canopyGeo, canopyMat);
  canopy.position.y = trunkH + canopyR*0.6;

  // --- Pousse (crÃ©Ã©e AVANT de toucher Ã  .visible !) ---
  const sproutGroup = new THREE.Group();

  const segH = 0.11;
  const segGeo = new THREE.CylinderGeometry(0.012, 0.016, segH, 6);
  const segMat = new THREE.MeshStandardMaterial({ color: 0x2a7a39, roughness: 0.9 });
  for (let i=0;i<3;i++){
    const seg = new THREE.Mesh(segGeo, segMat);
    seg.position.y = (i+0.5)*segH;
    seg.rotation.z = (i===0? 0.10 : i===1? 0.07 : 0.04);
    sproutGroup.add(seg);
  }
  const bud = new THREE.Mesh(new THREE.SphereGeometry(0.025, 10, 8),
    new THREE.MeshStandardMaterial({ color: 0x3aa45c, roughness:0.8, emissive:0x123d20, emissiveIntensity:0.2 }));
  bud.position.y = segH*3 + 0.02;
  sproutGroup.add(bud);
  const leafGeo = new THREE.PlaneGeometry(0.14, 0.08);
  const leafMat = new THREE.MeshStandardMaterial({ color: 0x4ec06a, side: THREE.DoubleSide, roughness:0.8 });
  const l1 = new THREE.Mesh(leafGeo, leafMat), l2 = new THREE.Mesh(leafGeo, leafMat);
  l1.position.set( 0.05, segH*2.1, 0); l1.rotation.set(0,  Math.PI*0.25,  Math.PI*0.45);
  l2.position.set(-0.05, segH*1.6, 0); l2.rotation.set(0, -Math.PI*0.25, -Math.PI*0.45);
  sproutGroup.add(l1, l2);
  sproutGroup.position.y = 0.01;

  // --- Groupe global + Ã‰TAT INITIAL (aprÃ¨s crÃ©ation de sproutGroup) ---
  const g = new THREE.Group();
  g.add(trunk, canopy, sproutGroup);

  // Ã©tat initial : uniquement la pousse
 const s0 = 0.0001; // quasi nul
trunk.visible = false;
canopy.visible = false;
sproutGroup.visible = true;

trunk.scale.set(s0, s0, s0);
canopy.scale.set(s0, s0, s0);

// ðŸ”§ positionne les centres pour garder la base Ã  y=0
trunk.position.y  = (trunkH * s0) / 2;
canopy.position.y = trunk.position.y + (trunkH * s0) + (canopyR * 0.6 * s0);
  // metadata pour updateTreeGrowth + label
  g.userData = { trunk, canopy, sproutGroup, trunkH, canopyR, treeLabel: null };

  return g;
}


// Mise Ã  lâ€™Ã©chelle selon lâ€™Ã¢ge
//const TREE_GROW_MS = 2 * 24 * 60 * 60 * 1000; // 2 jours
const CROSS_FADE_FRAC  = 0.20;  // 20% suivant = transition pousse->arbre
const SPROUT_ONLY_FRAC = 0.20;  // 20% du temps = pousse seule
//function smoothstep(t){ return t*t*(3-2*t); }
//function clamp01(v){ return Math.max(0, Math.min(1, v)); }

function updateTreeGrowth(group, ts){
  const age = (Date.now() - ts) * (window.GROW_DEBUG_MULT || 1);
  const t   = clamp01(age / TREE_GROW_MS);               // 0..1 de la croissance totale
  const u = group.userData; if (!u) return;

  // --- Phases d'affichage ---
  if (t < SPROUT_ONLY_FRAC) {
    // Pousse seule
    u.sproutGroup.visible = true;
    u.trunk.visible = false;
    u.canopy.visible = false;

    // Tag bas pendant la pousse
    if (u.treeLabel) u.treeLabel.position.y = 0.6;
  } else {
    // Arbre visible + croissance
    u.trunk.visible = true;
    u.canopy.visible = true;

    // progression d'arbre (hors phase "pousse seule")
    const tGrow = (t - SPROUT_ONLY_FRAC) / (1 - SPROUT_ONLY_FRAC);
    const k = smoothstep(clamp01(tGrow));               // 0..1 adouci

    // Ã‰chelle uniforme (0.2 â†’ 1.0)
    const base = 0.2 + 0.8 * k;

    // --- Ancrage : base du tronc au sol ---
    u.trunk.scale.set(base, base, base);
    const trunkTopY = ((u.trunkH || 1.5) * base);       // hauteur totale du tronc Ã  l'Ã©chelle
    u.trunk.position.y = trunkTopY / 2;                 // centre du tronc

    // --- CanopÃ©e posÃ©e sur le tronc ---
    u.canopy.scale.set(base, base, base);
    const R = (u.canopyR || 1.2) * base;                // "rayon" effectif de la canopÃ©e
    const overlap = 0.03;                                // petit chevauchement pour Ã©viter le jour
    u.canopy.position.y = (u.trunk.position.y + trunkTopY/2) + (R - overlap);
    // explication : centre canopÃ©e = sommet tronc + R - overlap
    // (bas de canopÃ©e = centre - R â‰ˆ sommet du tronc avec un lÃ©ger chevauchement)

    // Transition de la pousse (s'efface progressivement)
    const tFade = (t - SPROUT_ONLY_FRAC) / CROSS_FADE_FRAC;
    u.sproutGroup.visible = (t < SPROUT_ONLY_FRAC) || (tFade < 1);

    // Tag au-dessus de la cime
    if (u.treeLabel) u.treeLabel.position.y = u.canopy.position.y + 0.6;
  }

  // --- Tag : "Arbre de (pseudo) â€” XX%" ---
  // Pourcentage global 0..100 (depuis la plantation)
  const pct = Math.max(0, Math.min(100, Math.round(t * 100)));
  if (u.ownerName && u.treeLabel) {
    if (u._lastPct !== pct) {
      u._lastPct = pct;
      // Reconstruit un sprite propre (texte + %) â€” nÃ©cessite ownerName/labelColor stockÃ©s au spawn
      const text = `Arbre de ${u.ownerName} â€” ${pct}%`;
      const color = new THREE.Color(u.labelColor || "#88e5ff");
      const newLabel = makeLabelSprite(text, color, 220, 16, 0.009);
      newLabel.position.copy(u.treeLabel.position);
      // Remplace proprement
      group.remove(u.treeLabel);
      u.treeLabel.material.map?.dispose?.();
      u.treeLabel.material?.dispose?.();
      u.treeLabel = newLabel;
      group.add(newLabel);
    }
  }
}



const treeNodes = new Map();

onChildAdded(query(treesRef, limitToLast(1000)), snap => {
  const d = snap.val(); if (!d) return;
  const key = snap.key;
  const seed = (d.seed ?? d.ts ?? 1) ^ (key ? key.length*2654435761 : 0);

  const x = d.x || 0, z = d.z || 0, y = heightFn(x, z);
  const g = makeTreeMesh(seed, d.color || "#88e5ff");
  g.position.set(x, y, z);

  // --- CrÃ©ation du label avec pseudo et 0% au dÃ©part ---
  const treeLabel = makeLabelSprite(
    `Arbre de ${d.name || "FÃ©e"} â€” 0%`,
    d.color || "#88e5ff",
    200,   // largeur max
    16,    // taille police
    0.009  // scale
  );
  treeLabel.position.set(0, 1.6, 0);
  g.add(treeLabel);

  // --- Infos stockÃ©es pour updateTreeGrowth ---
  g.userData.treeLabel  = treeLabel;
  g.userData.ownerName  = d.name || "FÃ©e";
  g.userData.labelColor = d.color || "#88e5ff";

  scene.add(g);
  treeNodes.set(key, { group: g, ts: d.ts || Date.now() });
});

    /************ Bestiaire lÃ©ger ************/
    const MAX_CREATURES = 16;
    const creaturesRef = ref(db, '/creatures');
    const creatures = new Map();
    function trySpawnCreatureNear(x, z, color="#88e5ff"){
      if (creatures.size >= MAX_CREATURES) return;
      const type = Math.random()<0.6 ? "butterfly" : "spirit"; const y = heightFn(x,z) + 1.2; const seed = Math.floor(Math.random()*1e9);
      push(creaturesRef, { type, color, x0:+x.toFixed(2), y0:+y.toFixed(2), z0:+z.toFixed(2), seed, ts: Date.now() });
    }
    function makeButterflyMesh(color="#ffeeaa"){
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.2,8), new THREE.MeshStandardMaterial({ color: 0x333333, roughness:0.6 })); body.rotation.z = Math.PI/2;
      const wingMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), emissive: new THREE.Color(color).multiplyScalar(0.25), side: THREE.DoubleSide });
      const wingGeo = new THREE.PlaneGeometry(0.24, 0.17);
      const wL = new THREE.Mesh(wingGeo, wingMat), wR = new THREE.Mesh(wingGeo, wingMat);
      wL.position.set(0, 0.09, 0.06); wL.rotation.y =  Math.PI/2; wR.position.set(0, -0.09, 0.06); wR.rotation.y = -Math.PI/2;
      g.add(body, wL, wR); g.userData = { wL, wR }; return g;
    }
    function makeSpiritMesh(color="#aaffff"){
      const m = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 10), new THREE.MeshStandardMaterial({ color: new THREE.Color(color), emissive: new THREE.Color(color).multiplyScalar(0.5) }));
      const l = new THREE.PointLight(new THREE.Color(color), 0.8, 3.2, 2.0); l.position.set(0,0,0);
      const g = new THREE.Group(); g.add(m,l); return g;
    }
    function spawnCreatureNode(id, data){
      if (creatures.has(id)) return;
      const color = data?.color || "#88e5ff"; const mesh = (data?.type === "butterfly") ? makeButterflyMesh(color) : makeSpiritMesh(color);
      mesh.position.set(data?.x0||0, data?.y0||1.2, data?.z0||0); scene.add(mesh);
      creatures.set(id, { mesh, type: data?.type||"spirit", seed: data?.seed||1, ts: data?.ts||Date.now(), color, x0:data?.x0||0,y0:data?.y0||1.2,z0:data?.z0||0 });
      tint(1300, 0.12);
    }
    onChildAdded(query(creaturesRef, limitToLast(200)), snap=>{ const c = snap.val(); if (!c) return; spawnCreatureNode(snap.key, c); });
    function pickFlowerKeyForStep(creatureId, seed, step){
      const keys = Array.from(flowers.keys()); if (keys.length === 0) return null;
      let s = (seed ^ (step*2654435761) ^ (creatureId.length*97531)) >>> 0; const rnd = ()=> (s = (s*1664525 + 1013904223) >>> 0) / 4294967296;
      const idx = Math.floor(rnd() * keys.length); return keys[idx];
    }

    /************ PrÃ©sence + HUD ************/
    const FRESH_MS = 10_000;
    const onlineEl = document.getElementById('onlineCount'), whoEl = document.getElementById('who');
    let self = { uid:null, name:null, color:null, sendPose: ()=>{}, _pendingName:null, _pendingColor:null };
    const selfHalo = new THREE.PointLight(0x88e5ff, 0.9, 8, 2.0); scene.add(selfHalo);

    onAuthStateChanged(auth, async (user)=>{
      if (!user) return; self.uid = user.uid;
      let defaultHex = "#"+new THREE.Color().setHSL(Math.random(), 0.85, 0.60).getHexString();
      const lsName  = localStorage.getItem(LS_NAME), lsColor = localStorage.getItem(LS_COLOR);
      self.name  = sanitizeName(self._pendingName || lsName || ("FÃ©e#" + self.uid.slice(0,4)));
      self.color = toHexColor(self._pendingColor || lsColor || defaultHex);
      meRef = ref(db, `/presence/${self.uid}`);
      await set(meRef, { name:self.name, color:self.color, x:0, z:0, last: Date.now() }); onDisconnect(meRef).remove();

      let lastSent = 0;
      self.sendPose = (x,z)=>{ const now = performance.now(); if (now - lastSent < 100) return; lastSent = now;
        if (!Number.isFinite(x) || !Number.isFinite(z)) return; update(meRef, { x:+x.toFixed(2), z:+z.toFixed(2), last: Date.now() }); };

      onValue(ref(db, '/presence'), (snap)=>{
        const raw = snap.val() || {}; const now = Date.now(); const others = {}; const list = [];
        for (const [uid, data] of Object.entries(raw)) {
          const last = (typeof data?.last === 'number') ? data.last : (data?.last?.toMillis?.() ? data.last.toMillis() : 0);
          if (!last || (now - last) > FRESH_MS) continue;
          if (uid === self.uid) list.unshift({ uid, name: data?.name || "Moi", color: data?.color || "#ffffff", me:true });
          else { others[uid] = data; list.push({ uid, name: data?.name || ("FÃ©e#" + uid.slice(0,4)), color: data?.color || "#ffffff", me:false }); }
        }
        onlineEl.textContent = String(list.length); whoEl.innerHTML = "";
        for (const u of list){ const li = document.createElement('li'); li.className = "user" + (u.me ? " me" : "");
          const dot = document.createElement('span'); dot.className = "dot"; dot.style.background = u.color;
          const name = document.createElement('span'); name.textContent = u.name + (u.me ? " (moi)" : "");
          li.appendChild(dot); li.appendChild(name); whoEl.appendChild(li);
        }
        updateAvatars(others);
      });
    });

    /************ EntrÃ©e / overlay ************/
    document.getElementById('startBtn').addEventListener('click', async ()=>{
      const pseudoVal = sanitizeName(pseudoEl.value), colorVal  = toHexColor(colorEl.value || "#88e5ff");
      localStorage.setItem(LS_NAME,  pseudoVal); localStorage.setItem(LS_COLOR, colorVal);
      self._pendingName  = pseudoVal; self._pendingColor = colorVal; self.name  = pseudoVal; self.color = colorVal;
      document.getElementById('overlay').style.display = 'none';
      if (meRef && self.uid) { try { await update(meRef, { name: self.name, color: self.color }); } catch {} }
    });
    pseudoEl.addEventListener('change', async ()=>{ const v = sanitizeName(pseudoEl.value); localStorage.setItem(LS_NAME, v); self._pendingName = self.name = v; if (meRef && self.uid) { try { await update(meRef, { name:v }); } catch{} } });
    colorEl.addEventListener('change', async ()=>{ const v = toHexColor(colorEl.value); localStorage.setItem(LS_COLOR, v); self._pendingColor = self.color = v; if (meRef && self.uid) { try { await update(meRef, { color:v }); } catch{} } });

    /************ Boucle ************/
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta(), t = performance.now() / 1000;

      // Lissage axes â†’ direction (z avant+, x droite+)
      const LERP = 0.25;
      direction.set(
        THREE.MathUtils.lerp(direction.x, axes.x, LERP),
        0,
        THREE.MathUtils.lerp(direction.z || 0, -axes.y, LERP) // y joystick bas(+) â†’ reculÃ©
      );

      // vitesses
      const baseSpeed = IS_MOBILE ? 0.8 : 1.0;
      const speed = baseSpeed * Math.min(1, Math.hypot(direction.x, direction.z) || 0.0001);

      velocity.x -= velocity.x * 10 * dt;
      velocity.z -= velocity.z * 10 * dt;
      if (IS_MOBILE){
      velocity.x += direction.x * speed * dt;
      velocity.z += direction.z * speed * dt;
      }
      else
      {
        velocity.x += direction.x * speed * dt;
        velocity.z -= direction.z * speed * dt;
      }
      const obj = controls.getObject();
      obj.translateX( velocity.x);
      obj.translateZ( velocity.z);
      const yHere = heightFn(obj.position.x, obj.position.z);
      obj.position.y = yHere + 1.6;

      // CamÃ©ra par joystick droit (yaw/pitch), lissÃ©e, sans roll
camera.rotation.order = 'YXZ'; // Ã©vite tout roll implicite

const yawObj   = controls.getObject();            // yaw (Y)
const pitchObj = yawObj.children[0] || camera;    // pitch (X)

function clamp(x, min, max){ return Math.max(min, Math.min(max, x)); }

//IS_MOBILE = matchMedia('(hover:none) and (pointer:coarse)').matches;

let touchLookActive = false;
let lastX = 0, lastY = 0;
let vx = 0, vy = 0;

const SENS_YAW   = 0.0018;
const SENS_PITCH = 0.0018;
const SMOOTH     = 0.25;   // 0 = brut, 1 = trÃ¨s lissÃ©

// On ne touche pas au PC ; uniquement si mobile :
if (IS_MOBILE){
  const SENS_YAW = -1.8;    // sensibilitÃ© yaw (valeur â€œpar secondeâ€)
  const SENS_PITCH = -1.8;  // sensibilitÃ© pitch
  // On applique proportionnellement au dt pour Ãªtre framerate-indÃ©pendant
  const yawObj   = controls.getObject();
  const pitchObj = yawObj.children[0] || camera;

  yawObj.rotation.y += lookAxes.x * SENS_YAW * dt;

  const minPitch = -Math.PI/2 + 0.2;
  const maxPitch =  Math.PI/2 - 0.2;
  pitchObj.rotation.x = Math.max(minPitch, Math.min(maxPitch, pitchObj.rotation.x - lookAxes.y * SENS_PITCH * dt));

  // pas de roll
  pitchObj.rotation.z = 0;
  yawObj.rotation.z   = 0;
}

      selfHalo.color = new THREE.Color(self.color || "#88e5ff"); selfHalo.position.copy(obj.position); self.sendPose(obj.position.x, obj.position.z);

      // avatars
      for (const a of avatars.values()){
        a.group.position.x += (a.target.x - a.group.position.x) * 0.15;
        a.group.position.z += (a.target.z - a.group.position.z) * 0.15;
        a.group.position.y = heightFn(a.group.position.x, a.group.position.z);
      }

      // fx
      for (const fx of Array.from(liveFx)){ if (fx.userData?.tick){ fx.userData.tick(dt); if (!fx.parent) liveFx.delete(fx); } }

      // herbe
      if (grass?.tick) grass.tick(t);

      // lucioles
      tickFireflies(fireflies, dt);

      // crÃ©atures
      const now = Date.now(), CYCLE_MS = 8000;
      for (const [id, c] of creatures.entries()){
        const mesh = c.mesh; const step = Math.floor((now - c.ts) / CYCLE_MS); const t01 = ((now - c.ts) % CYCLE_MS) / CYCLE_MS;
        const keyA = pickFlowerKeyForStep(id, c.seed, Math.max(0, step-1)), keyB = pickFlowerKeyForStep(id, c.seed, step);
        const fa = keyA && flowers.get(keyA), fb = keyB && flowers.get(keyB);
        const ax = (fa?.x ?? c.x0), az = (fa?.z ?? c.z0), bx = (fb?.x ?? ax), bz = (fb?.z ?? az);
        const ay = heightFn(ax, az) + 1.0, by = heightFn(bx, bz) + 1.0, tt = t01*t01*(3-2*t01);
        mesh.position.set(ax + (bx-ax)*tt, ay + (by-ay)*tt + Math.sin((t01+id.length)*Math.PI*2)*0.12, az + (bz-az)*tt);
        if (c.type === "butterfly" && mesh.userData?.wL && mesh.userData?.wR){ const flap = Math.sin(now/120) * 0.9; mesh.userData.wL.rotation.z =  flap; mesh.userData.wR.rotation.z = -flap; }
      }
      for (const { group, ts } of treeNodes.values()){
        updateTreeGrowth(group, ts);
      }
      renderer.render(scene, camera);
    }
    animate();

    /************ Resize ************/
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
    });

    /************ Chat data hooks ************/
    const messagesListEl = document.getElementById('messages');
    
  </script>

  <!--
  ============================
  RÃˆGLES REALTIME DATABASE (exemple solide)
  {
    "rules": {
      ".read": true,
      "presence": { "$uid": { ".write": "auth != null && auth.uid === $uid" } },
      "chat": { "global": { "$msgId": { ".write": "auth != null && newData.child('text').val().length <= 200" } } },
      "events": { "spells": { "$id": { ".write": "auth != null", ".validate": "newData.hasChildren(['uid','x','z','color','ts'])" } } },
      "garden": { "$id": { ".write": "auth != null", ".validate": "newData.hasChildren(['uid','name','x','z','color','ts','seed'])" } },
      "creatures": { "$id": { ".write": "auth != null", ".validate": "newData.hasChildren(['type','x0','y0','z0','seed','ts'])" } }
    }
  }
  ============================
  -->
</body>
</html>
