<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Jardin F√©erique ‚Äî Stable</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#05060a; overflow:hidden; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:#fff; }
    #overlay {
      position: absolute; inset: 0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: rgba(0,0,0,.85); z-index: 10; text-align:center; gap:10px; padding:16px;
    }
    #overlay button {
      padding:10px 16px; border:0; border-radius:10px; font-weight:700; cursor:pointer; color:#0b0d14;
      background: linear-gradient(135deg,#7dd3fc,#34d399);
    }
    #overlay input[type="text"] { padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.08); color:#fff; }
    #overlay input[type="color"] { width:48px; height:32px; border:none; background:transparent; }

    #chat {
      position: absolute; left: 12px; bottom: 12px; width: 320px; max-height: 240px;
      background: rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:6px;
    }
    #messages { flex:1; overflow:auto; list-style:none; margin:0; padding:0; font-size:14px; }
    #messages li { margin: 2px 0; }
    #chat form { display:flex; gap:6px; }
    #msg { flex:1; padding:8px; border:1px solid rgba(255,255,255,.15); border-radius:8px; background:rgba(255,255,255,.08); color:#fff; }
    #send { padding:8px 10px; border:0; border-radius:8px; background:#7dd3fc; color:#0b0d14; font-weight:700; cursor:pointer; }

    #hud {
      position:absolute; right:12px; top:12px; padding:10px 12px; width: 320px;
      background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.08); border-radius:10px; font-size:13px;
      display:flex; flex-direction:column; gap:8px;
    }
    #who { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:6px; max-height: 260px; overflow:auto; }
    .user { display:flex; align-items:center; gap:8px; background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.06); padding:6px 8px; border-radius:8px; }
    .dot { width:10px; height:10px; border-radius:50%; box-shadow: 0 0 10px rgba(255,255,255,.4) inset; }
    .me  { outline: 1px dashed rgba(255,255,255,.3); }
    .hint { position:absolute; left:50%; transform:translateX(-50%); bottom:8px; opacity:.85; font-size:12px; background:rgba(0,0,0,.5); padding:4px 8px; border-radius:8px; display:none; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .btn { padding:6px 8px; border:0; border-radius:8px; background:#1f2937; color:#fff; cursor:pointer; font-weight:600; }
    .btn.active { background:#7dd3fc; color:#0b0d14; }
    select { background:#0f172a; color:#fff; border:1px solid rgba(255,255,255,.18); border-radius:8px; padding:6px 8px; }
  </style>
</head>
<body>
  <div id="overlay">
    <h1>Jardin F√©erique ‚Äî Salon Global</h1>
    <p>Choisis ton pseudo et ta couleur ‚Ä¢ ZQSD = bouger ‚Ä¢ Souris = regarder ‚Ä¢ Entr√©e = chat</p>
    <label style="display:block; margin:6px 0;">
      Pseudo : <input id="pseudo" type="text" maxlength="16" placeholder="Ton nom" />
    </label>
    <label style="display:block; margin:6px 0;">
      Couleur : <input id="color" type="color" value="#ff66ff" />
    </label>
    <button id="startBtn">Entrer</button>
  </div>

  <div id="chat">
    <ul id="messages"></ul>
    <form id="chatForm">
      <input id="msg" maxlength="200" placeholder="Message‚Ä¶" autocomplete="off" />
      <button id="send" type="submit">Envoyer</button>
    </form>
  </div>

  <div id="hud">
    <div class="row"><strong>Connect√©s :</strong> <span id="onlineCount">1</span></div>
    <div class="row">
      <span><strong>Son :</strong></span>
      <div style="display:flex; gap:6px; align-items:center;">
        <button id="audioToggle" class="btn">OFF</button>
        <input id="audioVol" type="range" min="0" max="1" step="0.01" value="0.2" />
      </div>
    </div>
    <div class="row">
      <span><strong>Herbe :</strong></span>
      <select id="grassQuality">
        <option value="1000">Faible</option>
        <option value="3000" selected>Moyen</option>
        <option value="6000">√âlev√©</option>
        <option value="10000">Ultra</option>
      </select>
    </div>
    <ul id="who"></ul>
    <div style="opacity:.8; font-size:12px;">E = ‚ú® Aurore ‚Ä¢ F = üå∏ Fleur</div>
  </div>

  <div id="hint" class="hint">Clique dans la sc√®ne pour reprendre le contr√¥le</div>

  <!-- Modal non bloquant pour planter une fleur -->
  <div id="flowerModal" style="position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.55); z-index:20;">
    <div style="width:min(92vw, 420px); background:#0b1020; border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:14px;">
      <h3 style="margin:0 0 8px; font-size:18px;">Planter une fleur üå∏</h3>
      <p style="margin:0 0 10px; opacity:.9; font-size:14px;">
        La fleur sera plant√©e <b>pour toujours</b>. Tu peux ajouter un message (optionnel) :
      </p>
      <textarea id="flowerMsg" rows="3" maxlength="140" placeholder="Ton message (140 caract√®res max)"
        style="width:100%; resize:vertical; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); color:#fff; border-radius:8px; padding:8px; margin-bottom:10px;"></textarea>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="fmCancel" class="btn">Annuler</button>
        <button id="fmNoMsg" class="btn">Sans message</button>
        <button id="fmWithMsg" class="btn active">Planter</button>
      </div>
    </div>
  </div>

  <!-- Three.js & Controls en LOCAL -->
  <script src="./three.min.js"></script>
  <script src="./PointerLockControls.js"></script>

  <!-- App + Firebase -->
  <script type="module">
    /************ Firebase ************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged,
      setPersistence, inMemoryPersistence, signOut
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
    import {
      getDatabase, ref, set, update, onValue, onDisconnect,
      push, query, limitToLast, onChildAdded
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-database.js";

    /** üîß Remplace par TES cl√©s **/
const firebaseConfig = {
  apiKey: "AIzaSyBUiGGKBssQ_wTrz5uYBkHRKeMk0GNWeFI",
  authDomain: "jardin-feerique.firebaseapp.com",
  databaseURL: "https://jardin-feerique-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "jardin-feerique",
  storageBucket: "jardin-feerique.firebasestorage.app",
  messagingSenderId: "240867851823",
  appId: "1:240867851823:web:43529ae5008fe9dcd910da",
  measurementId: "G-YCZ4XC9PQ1"
};
    const appFB = initializeApp(firebaseConfig);
    const appCheck = initializeAppCheck(appFB, {
  provider: new ReCaptchaV3Provider('6LcI9LMrAAAAAF6biBHZG20s55PAE24lsPyAwSwZ'), // üîπ Mets ta cl√© site ici
  isTokenAutoRefreshEnabled: true
});
    const auth = getAuth(appFB);
    const db = getDatabase(appFB);

    await setPersistence(auth, inMemoryPersistence);
    if (auth.currentUser) await signOut(auth);
    await signInAnonymously(auth);

    let meRef = null;

    import { initializeAppCheck, ReCaptchaV3Provider } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app-check.js";

    /************ Utils pseudo & couleur ************/
    function sanitizeName(s){ return (s || "").toString().trim().slice(0,16) || "F√©e"; }
    function toHexColor(input, fallback="#88e5ff"){
      try { const col = new THREE.Color(input || fallback); return "#"+col.getHexString(); }
      catch(e){ return fallback; }
    }
    const LS_NAME="jf_name", LS_COLOR="jf_color", LS_GRASS="jf_grass";

    /************ WebAudio ‚Äî ambiance douce (OFF par d√©faut) ************/
    let AudioCtx = null, ctx = null, windGain = null, masterGain = null, ambOn = false;
    function audioInit(){
      if (AudioCtx) return;
      AudioCtx = window.AudioContext || window.webkitAudioContext;
      ctx = new AudioCtx();

      // Master (volume)
      masterGain = ctx.createGain(); masterGain.gain.value = parseFloat(document.getElementById('audioVol').value); masterGain.connect(ctx.destination);

      // Vent doux = bruit blanc -> lowpass + gentle LFO
      const bufferSize = 2 * ctx.sampleRate;
      const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1; // white noise

      const noise = ctx.createBufferSource();
      noise.buffer = noiseBuffer; noise.loop = true;

      const lowpass = ctx.createBiquadFilter(); lowpass.type = 'lowpass'; lowpass.frequency.value = 600; lowpass.Q.value = 0.5;
      const lfo = ctx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0.07;
      const lfoGain = ctx.createGain(); lfoGain.gain.value = 120; // moduler fc ¬±120 Hz
      lfo.connect(lfoGain); lfoGain.connect(lowpass.frequency);

      windGain = ctx.createGain(); windGain.gain.value = 0.0;

      noise.connect(lowpass); lowpass.connect(windGain); windGain.connect(masterGain);
      noise.start(); lfo.start();
    }
    function audioToggle(){
      if (!AudioCtx) audioInit();
      if (ctx.state === 'suspended') ctx.resume();
      ambOn = !ambOn;
      const now = ctx.currentTime;
      windGain.gain.cancelScheduledValues(now);
      windGain.gain.linearRampToValueAtTime(ambOn ? 0.08 : 0.0, now + 0.3);
      document.getElementById('audioToggle').textContent = ambOn ? 'ON' : 'OFF';
      document.getElementById('audioToggle').classList.toggle('active', ambOn);
    }
    function setMasterVolume(v){
      if (!masterGain) return;
      masterGain.gain.value = v;
    }
    function tint(freq=1200, dur=0.22) {
      if (!ctx) return;
      const o = ctx.createOscillator(); o.type='triangle'; o.frequency.value=freq;
      const g = ctx.createGain(); g.gain.value=0.0;
      o.connect(g); g.connect(masterGain);
      const now = ctx.currentTime;
      g.gain.linearRampToValueAtTime(0.07, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
      o.start(now); o.stop(now+dur+0.05);
    }

    const audioBtn = document.getElementById('audioToggle');
    const audioVol = document.getElementById('audioVol');
    audioBtn.addEventListener('click', ()=>{ audioToggle(); if (ambOn) tint(1500, 0.15); });
    audioVol.addEventListener('input', ()=> setMasterVolume(parseFloat(audioVol.value)));

    /************ THREE: sc√®ne ************/
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060a);
    scene.fog = new THREE.FogExp2(0x0a1022, 0.012);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1200);
    camera.position.set(0, 1.6, 6);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    const hint = document.getElementById('hint');
    controls.addEventListener('unlock', ()=>{ hint.style.display = 'block'; });
    controls.addEventListener('lock',   ()=>{ hint.style.display = 'none'; });
    renderer.domElement.addEventListener('click', ()=>{ if (!controls.isLocked) controls.lock(); });

    // Lumi√®res globales (simple et s√ªr)
    scene.add(new THREE.HemisphereLight(0x7dd3fc, 0x1e293b, 0.9));
    const sun = new THREE.DirectionalLight(0xffffff, 0.15);
    sun.position.set(30,60,20);
    scene.add(sun);

    /************ Monde : terrain ondul√© ************/
    function heightFn(x,z){
      return 0.6*Math.sin(x*0.04)*Math.cos(z*0.035) + 0.25*Math.sin((x+z)*0.06);
    }
    function noise2(x, z){
      return Math.sin(x*0.11 + Math.cos(z*0.07)*2.1) * 0.5 + Math.cos(z*0.13 + Math.sin(x*0.05)*1.7) * 0.5;
    }

    const SIZE = 280, SEG = 140;
    const terrainGeo = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG);
    // Pousser la hauteur dans Z, puis mettre √† plat
    {
      const pos = terrainGeo.attributes.position;
      const colors = new Float32Array(pos.count * 3);
      const c1 = new THREE.Color(0x104f33);
      const c2 = new THREE.Color(0x2e8b57);
      for (let i=0;i<pos.count;i++){
        const x = pos.getX(i);
        const z = pos.getY(i);
        const h = heightFn(x, z);
        pos.setZ(i, h);
        const shade = THREE.MathUtils.clamp(0.55 + h*0.08 + noise2(x,z)*0.08, 0.35, 0.9);
        const col = c1.clone().lerp(c2, shade);
        colors[i*3+0] = col.r; colors[i*3+1] = col.g; colors[i*3+2] = col.b;
      }
      terrainGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      pos.needsUpdate = true;
    }
    terrainGeo.rotateX(-Math.PI/2);
    terrainGeo.computeVertexNormals();

    const ground = new THREE.Mesh(
      terrainGeo,
      new THREE.MeshStandardMaterial({ vertexColors:true, roughness:0.95, metalness:0.0 })
    );
    ground.receiveShadow = true;
    scene.add(ground);

    /************ Herbe proc√©durale (InstancedMesh) ‚Äì simple & stable ************/
    const grassSelect = document.getElementById('grassQuality');
    const savedGrass = localStorage.getItem(LS_GRASS);
    if (savedGrass && grassSelect.querySelector(`option[value="${savedGrass}"]`)) grassSelect.value = savedGrass;

    let grass = null;
    function buildGrass(bladeCount){
      if (grass?.dispose) grass.dispose();

      const bladeGeo = new THREE.PlaneGeometry(0.06, 0.55, 1, 2);
      bladeGeo.translate(0, 0.275, 0);
      const bladeMat = new THREE.MeshStandardMaterial({
        color: 0x2ea043, side: THREE.DoubleSide, roughness: 0.95, metalness: 0.0
      });
      const inst = new THREE.InstancedMesh(bladeGeo, bladeMat, bladeCount);
      inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(inst);

      const dummy = new THREE.Object3D();
      const phases = new Float32Array(bladeCount);
      const px = new Float32Array(bladeCount);
      const pz = new Float32Array(bladeCount);
      const baseY = new Float32Array(bladeCount);

      const R = 95;
      for (let i=0;i<bladeCount;i++){
        const a = Math.random()*Math.PI*2;
        const r = Math.sqrt(Math.random()) * R;
        const x = Math.cos(a)*r;
        const z = Math.sin(a)*r;
        const y = heightFn(x,z) + 0.02;

        px[i]=x; pz[i]=z; baseY[i]=y;
        phases[i] = Math.random()*Math.PI*2;

        dummy.position.set(x,y,z);
        dummy.rotation.set(0, a, 0);
        dummy.scale.set(1, 0.8 + Math.random()*0.5, 1);
        dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);
      }
      inst.instanceMatrix.needsUpdate = true;

      const swayDummy = new THREE.Object3D();
      function tick(t){
        const wind = 0.15 + 0.08*Math.sin(t*0.6);
        for (let i=0;i<bladeCount;i++){
          const sway = 0.15 * Math.sin(t*1.5 + phases[i] + px[i]*0.04 + pz[i]*0.04) * wind;
          swayDummy.position.set(px[i], baseY[i], pz[i]);
          swayDummy.rotation.set(sway, 0, 0);
          swayDummy.scale.set(1, 0.8 + Math.abs(Math.sin(phases[i]))*0.5, 1);
          swayDummy.updateMatrix();
          inst.setMatrixAt(i, swayDummy.matrix);
        }
        inst.instanceMatrix.needsUpdate = true;
      }
      function dispose(){
        scene.remove(inst);
        inst.geometry?.dispose?.();
        inst.material?.dispose?.();
      }
      return { tick, dispose };
    }
    grass = buildGrass(parseInt(grassSelect.value,10));
    grassSelect.addEventListener('change', ()=>{
      const count = parseInt(grassSelect.value,10);
      localStorage.setItem(LS_GRASS, String(count));
      grass = buildGrass(count);
      tint(1700,0.15);
    });

    /************ Etoiles (safe) ************/
   let stars = null;
function buildStars(count = 1400) {
  if (stars) { scene.remove(stars); stars.geometry?.dispose?.(); stars.material?.dispose?.(); stars = null; }

  const starGeo = new THREE.BufferGeometry();
  const starPos = new Float32Array(count * 3);
  for (let i = 0; i < starPos.length; i += 3) {
    starPos[i]   = (Math.random() - 0.5) * 1200;       // x
    starPos[i+1] = Math.random() * 600 + 160;          // y haut au-dessus du fog
    starPos[i+2] = (Math.random() - 0.5) * 1200;       // z
  }
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));

  const starMat = new THREE.PointsMaterial({
    size: 1.6,              // plus grand
    transparent: true,
    opacity: 0.95,
    depthWrite: false,      // √©vite d‚Äô√™tre ‚Äúmasqu√©‚Äù
    blending: THREE.AdditiveBlending,
    color: 0xffffff,
    fog: false              // ignorent le fog
  });

  stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);
}
// appelle une fois apr√®s la cr√©ation de la sc√®ne :
buildStars();


let fireflies = null;
function buildFireflies(count = 280, radius = 180) {
  if (fireflies) { scene.remove(fireflies); fireflies.geometry?.dispose?.(); fireflies.material?.dispose?.(); fireflies = null; }

  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const vel = new Float32Array(count * 3);
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2, r = Math.sqrt(Math.random()) * radius;
    const x = Math.cos(a) * r, z = Math.sin(a) * r;
    pos[i*3+0] = x;
    pos[i*3+2] = z;
    pos[i*3+1] = heightFn(x, z) + 0.8 + Math.random() * 3;
    vel[i*3+0] = (Math.random() - 0.5) * 0.06;
    vel[i*3+1] = (Math.random() - 0.5) * 0.03;
    vel[i*3+2] = (Math.random() - 0.5) * 0.06;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.10,
    transparent: true,
    opacity: 1.0,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    color: 0xfff7b1,  // un peu dor√©
    fog: false
  });

  fireflies = new THREE.Points(geo, mat);
  fireflies.userData = { vel, radius };
  scene.add(fireflies);
}
function tickFireflies(pp, dt){
  if (!pp) return;
  const p = pp.geometry.attributes.position.array;
  const v = pp.userData.vel;
  for (let i = 0; i < v.length; i += 3) {
    v[i+0] += (Math.random()-0.5)*0.002;
    v[i+1] += (Math.random()-0.5)*0.002;
    v[i+2] += (Math.random()-0.5)*0.002;
    p[i+0] += v[i+0]*dt*60;
    p[i+1] += v[i+1]*dt*60;
    p[i+2] += v[i+2]*dt*60;
    const x = p[i+0], z = p[i+2];
    const h = heightFn(x, z) + 0.5;
    if (p[i+1] < h) p[i+1] = h;
    if (p[i+1] > h + 4.0) p[i+1] = h + 4.0;
  }
  pp.geometry.attributes.position.needsUpdate = true;
}
// appelle une fois apr√®s la cr√©ation du terrain :
buildFireflies();
    /************ Overlay (pseudo/couleur) ************/
    const pseudoEl = document.getElementById('pseudo');
    const colorEl  = document.getElementById('color');
    const savedName  = localStorage.getItem(LS_NAME);
    const savedColor = localStorage.getItem(LS_COLOR);
    if (savedName)  pseudoEl.value = savedName;
    if (savedColor) colorEl.value  = savedColor;

    /************ Aides entr√©e/clavier ************/
    function isTyping() {
      const el = document.activeElement;
      const modalOpen = document.getElementById('flowerModal')?.style.display === 'grid';
      const typing = el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable);
      return modalOpen || typing;
    }

    /************ D√©placements & actions ************/
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const move = { forward:false, backward:false, left:false, right:false };

    addEventListener('keydown', (e)=>{
      if (isTyping()) return;

      if (e.code === 'Enter') {
        e.preventDefault();
        document.getElementById('msg').focus();
        return;
      }

      if (e.code === 'KeyW' || e.code === 'KeyZ') { e.preventDefault(); move.forward = true; }
      if (e.code === 'KeyS') { e.preventDefault(); move.backward = true; }
      if (e.code === 'KeyA' || e.code === 'KeyQ') { e.preventDefault(); move.left = true; }
      if (e.code === 'KeyD') { e.preventDefault(); move.right = true; }

      if (e.code === 'KeyE') { e.preventDefault(); castAurora(); tint(1300,0.12); }
      if (e.code === 'KeyF') {
        e.preventDefault();
        if (controls.isLocked) controls.unlock(); // coupe le d√©placement souris
        plantFlower();
      }
    });
    addEventListener('keyup', (e)=>{
      if (isTyping()) return;
      if (e.code === 'KeyW' || e.code === 'KeyZ') move.forward = false;
      if (e.code === 'KeyS') move.backward = false;
      if (e.code === 'KeyA' || e.code === 'KeyQ') move.left = false;
      if (e.code === 'KeyD') move.right = false;
    });

    // Emp√™cher les touches de ‚Äúfuir‚Äù des inputs
    const msgInput = document.getElementById('msg');
    ['keydown','keyup','keypress'].forEach(ev=> msgInput.addEventListener(ev, (e)=> e.stopPropagation()));
    ;[pseudoEl, colorEl].forEach(el => ['keydown','keyup','keypress'].forEach(ev=> el.addEventListener(ev, (e)=> e.stopPropagation())));
    ;['flowerMsg','fmCancel','fmNoMsg','fmWithMsg'].forEach(id=>{
      const el = document.getElementById(id); if (!el) return;
      ['keydown','keyup','keypress','click'].forEach(ev=> el.addEventListener(ev, (e)=> e.stopPropagation()));
    });

    /************ Chat ************/
    const messagesList = document.getElementById('messages');
    const chatForm = document.getElementById('chatForm');
    const chatRef = ref(db, '/chat/global');

    onChildAdded(query(chatRef, limitToLast(50)), snap=>{
      const m = snap.val();
      const li = document.createElement('li');
      li.textContent = `[${m.name}] ${m.text}`;
      messagesList.appendChild(li);
      messagesList.scrollTop = messagesList.scrollHeight;
    });

    chatForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      const text = (msgInput.value || "").trim();
      if (!text) return;
      push(chatRef, { name: self.name || "F√©e", text, ts: Date.now() });
      msgInput.value = "";
    });

    /************ Avatars + labels ************/
    const avatars = new Map();

    function roundRect(ctx, x, y, w, h, r) {
      r = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r);
      ctx.arcTo(x,   y,   x+w, y,   r);
      ctx.closePath();
    }

    // Wrap auto + taille adapt√©e
    function makeLabelSprite(text, color, maxW=240, fs=28, scale=0.012) {
      const lines = [];
      const words = String(text).split(/\s+/).filter(Boolean);
      const cvs = document.createElement('canvas');
      const ctx = cvs.getContext('2d');
      const padX = 10, padY = 8;
      ctx.font = `700 ${fs}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;

      // wrap
      let line = '';
      for (const w of words) {
        const test = line ? (line + ' ' + w) : w;
        if (ctx.measureText(test).width + padX*2 > maxW) {
          if (line) lines.push(line);
          line = w;
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      if (lines.length === 0) lines.push(' ');

      const w = Math.ceil(Math.max(...lines.map(l => ctx.measureText(l).width))) + padX*2;
      const lineH = fs + 4;
      const h = lineH*lines.length + padY*2;

      cvs.width = Math.max(64, w);
      cvs.height = Math.max(32, h);

      // bg
      ctx.fillStyle = 'rgba(0,0,0,0.55)'; roundRect(ctx, 0, 0, cvs.width, cvs.height, 10); ctx.fill();
      // text
      const col = (color?.getStyle ? color.getStyle() : (typeof color === 'string' ? color : '#ffffff'));
      ctx.fillStyle = col; ctx.textBaseline = 'middle';
      lines.forEach((l, i)=> ctx.fillText(l, padX, Math.floor(padY + lineH*i + lineH/2)));

      const tex = new THREE.CanvasTexture(cvs); tex.minFilter = THREE.LinearFilter;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthTest:false, depthWrite:false });
      const spr = new THREE.Sprite(mat); spr.scale.set(cvs.width*scale, cvs.height*scale, 1); spr.renderOrder = 999; return spr;
    }

    function spawnAvatar(uid, data){
      if (avatars.has(uid)) return;
      const name = (data?.name ?? ("F√©e#" + uid.slice(0,4)));
      const color = new THREE.Color( toHexColor(data?.color, "#ff0077") );

      const group = new THREE.Group();
      const radius = 1.1;
      const body = new THREE.Mesh(
        new THREE.SphereGeometry(radius, 22, 18),
        new THREE.MeshStandardMaterial({ color, emissive: color.clone().multiplyScalar(0.25) })
      );
      body.position.set(0, radius, 0);

      const label = makeLabelSprite(name, color, 220, 26, 0.0115);
      label.position.set(0, radius + 0.8, 0);

      const halo = new THREE.PointLight(color, 1.0, 8, 2.0);
      halo.position.set(0, radius, 0);

      group.add(body, label, halo);
      scene.add(group);
      avatars.set(uid, { group, body, label, halo, target: { x:0, z:0 }, color, name });
    }
    function despawnAvatar(uid){ const a = avatars.get(uid); if (!a) return; scene.remove(a.group); avatars.delete(uid); }
    function updateAvatars(everyone){
      for (const [uid, data] of Object.entries(everyone)) {
        if (!avatars.has(uid)) spawnAvatar(uid, data);
        const a = avatars.get(uid);
        const x = Number.isFinite(data?.x) ? data.x : a.group.position.x;
        const z = Number.isFinite(data?.z) ? data.z : a.group.position.z;
        a.target = { x, z };
        const newName = data?.name ?? a.name;
        const newColor = new THREE.Color( toHexColor(data?.color, "#ff0077") );
        if (newName !== a.name || newColor.getHex() !== a.color.getHex()){
          a.name = newName; a.color = newColor;
          a.group.remove(a.label);
          a.label = makeLabelSprite(a.name, a.color, 220, 26, 0.0115);
          a.label.position.set(0, 1.1 + 0.8, 0);
          a.group.add(a.label);
          a.halo.color = a.color;
          a.body.material.color = a.color;
          a.body.material.emissive = a.color.clone().multiplyScalar(0.25);
        }
      }
      for (const uid of Array.from(avatars.keys())) if (!everyone[uid]) despawnAvatar(uid);
    }

    /************ Effets stables (pas de recr√©ation de g√©om√©trie par frame) ************/
    const liveFx = new Set();
    function spawnRing(x,z,color="#88e5ff"){
      const y = heightFn(x,z) + 0.02;
      const geo = new THREE.RingGeometry(0.4, 0.42, 48);
      const mat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.9, side:THREE.DoubleSide, depthWrite:false });
      const ring = new THREE.Mesh(geo, mat);
      ring.rotation.x = -Math.PI/2; ring.position.set(x, y, z);
      ring.userData = { t:0 };
      ring.userData.tick = (dt)=>{
        const u = ring.userData; u.t += dt;
        const s = 1 + u.t*2.2;
        ring.scale.set(s,s,1);
        ring.material.opacity = Math.max(0, 0.9 - u.t*0.8);
        if (u.t>1.4) { scene.remove(ring); ring.geometry.dispose(); ring.material.dispose(); }
      };
      scene.add(ring); return ring;
    }
    function spawnSparks(x,z,color="#88e5ff"){
      const y0 = heightFn(x,z) + 1.2;
      const count = 60, geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count*3), vel = new Float32Array(count*3);
      for (let i=0;i<count;i++){
        pos[i*3+0]=x; pos[i*3+1]=y0; pos[i*3+2]=z;
        const a = Math.random()*Math.PI*2; const s = 0.35 + Math.random()*0.9;
        vel[i*3+0]=Math.cos(a)*s; vel[i*3+1]=0.9+Math.random()*1.1; vel[i*3+2]=Math.sin(a)*s;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      const mat = new THREE.PointsMaterial({ size:0.07, color, transparent:true, opacity:1.0, depthWrite:false });
      const pp = new THREE.Points(geo, mat);
      pp.userData = { vel, life: 1.1 };
      pp.userData.tick = (dt)=>{
        const p = pp.geometry.attributes.position.array, v = pp.userData.vel; pp.userData.life -= dt;
        for (let i=0;i<v.length;i+=3){ v[i+1] -= 0.98*dt; p[i+0]+=v[i+0]*dt; p[i+1]+=v[i+1]*dt; p[i+2]+=v[i+2]*dt; }
        pp.material.opacity = Math.max(0, pp.userData.life/1.1); pp.geometry.attributes.position.needsUpdate = true;
        if (pp.userData.life<=0) { scene.remove(pp); pp.geometry.dispose(); pp.material.dispose(); }
      };
      scene.add(pp); return pp;
    }

    /************ Fleurs jolies & labels compacts ************/
    function rng(seed){ return ()=> (seed = (seed*1664525 + 1013904223) >>> 0) / 4294967296; }
    function lerp(a,b,t){ return a+(b-a)*t; }
    function clamp01(x){ return Math.min(1, Math.max(0, x)); }
    function harmonizeColor(baseHex, r01){
      const c = new THREE.Color(baseHex);
      const hsl = { h:0,s:0,l:0 }; c.getHSL(hsl);
      const petal = new THREE.Color().setHSL(hsl.h + lerp(-0.03,0.03,r01()), clamp01(hsl.s*0.8 + 0.15), clamp01(lerp(0.55,0.75,r01())));
      const pistil = new THREE.Color().setHSL(lerp(0.10,0.16,r01()), lerp(0.6,0.9,r01()), lerp(0.5,0.7,r01()));
      const stem = new THREE.Color().setHSL(lerp(0.30,0.38,r01()), lerp(0.35,0.6,r01()), lerp(0.25,0.45,r01()));
      return { petal, pistil, stem };
    }
    function petalGeometry(type, r01, radius, length, thickness){
      const t = type;
      const geo = new THREE.PlaneGeometry(radius, length, 1, 8);
      const posG = geo.attributes.position;
      for (let i=0;i<posG.count;i++){
        const y = posG.getY(i);
        const bend = Math.sin((y/length)*Math.PI)*thickness;
        const x = posG.getX(i);
        posG.setX(i, x * (t===1 ? 1.15 : t===2 ? 0.85 : 1.0));
        posG.setZ(i, bend * (t===2 ? 1.4 : 1.0));
      }
      posG.needsUpdate = true; geo.computeVertexNormals(); return geo;
    }
    function makeFlowerLabel(name, ts, color, msg){
      const date = new Date(ts || Date.now());
      const dd = String(date.getDate()).padStart(2,'0');
      const mm = String(date.getMonth()+1).padStart(2,'0');
      const yyyy = date.getFullYear();
      let text = `${name} ‚Ä¢ ${dd}/${mm}/${yyyy}`;
      if (msg && (msg=msg.trim())) text += " ‚Äî " + msg.slice(0,140);
      return makeLabelSprite(text, color, 260, 24, 0.0105); // plus compact
    }
    function spawnFlowerFancy(f, key){
      const seed = ((f.seed ?? f.ts ?? 1) ^ (key ? key.length*2654435761 : 0)) >>> 0;
      const rnd = rng(seed);
      const variant = Math.floor(rnd()*3);
      const petals = 5 + Math.floor(rnd()*3); // 5..7 (un peu plus l√©ger)
      const radius = lerp(0.16, 0.26, rnd());
      const length = lerp(0.35, 0.52, rnd());
      const thickness = lerp(0.06, 0.1, rnd());
      const height = lerp(0.55, 0.8, rnd());
      const lean = lerp(-0.22, 0.22, rnd());
      const colors = harmonizeColor(f.color || "#a0ffcc", rnd);

      const x = f.x || 0, z = f.z || 0, y = heightFn(x,z);
      const g = new THREE.Group(); g.position.set(x, y, z);

      const stemMat = new THREE.MeshStandardMaterial({ color: colors.stem });
      const stem = new THREE.Group();
      for (let i=0;i<3;i++){
        const seg = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.045, height/3, 10), stemMat);
        seg.position.y = (i+0.5)*(height/3);
        stem.add(seg);
      }
      stem.rotation.z = lean; g.add(stem);

      const leafGeo = new THREE.PlaneGeometry(0.26, 0.16, 1, 4);
      const leafMat = new THREE.MeshStandardMaterial({ color: colors.stem, side: THREE.DoubleSide });
      const leaf1 = new THREE.Mesh(leafGeo, leafMat);
      const leaf2 = new THREE.Mesh(leafGeo, leafMat);
      leaf1.position.set(0.08, height*0.45, 0); leaf1.rotation.set(0, Math.PI*0.15, -Math.PI*0.35);
      leaf2.position.set(-0.08, height*0.3, 0);  leaf2.rotation.set(0, -Math.PI*0.15, Math.PI*0.35);
      g.add(leaf1, leaf2);

      const pistil = new THREE.Mesh(
        new THREE.SphereGeometry(0.085, 14, 10),
        new THREE.MeshStandardMaterial({ color: colors.pistil, emissive: colors.pistil.clone().multiplyScalar(0.22) })
      );
      pistil.position.y = height + length*0.5;
      g.add(pistil);

      const petalsGroup = new THREE.Group();
      const petMat = new THREE.MeshStandardMaterial({
        color: colors.petal, emissive: colors.petal.clone().multiplyScalar(0.1), side: THREE.DoubleSide
      });
      const petGeo = petalGeometry(variant, rnd, radius, length, thickness);
      for (let i=0;i<petals;i++){
        const p = new THREE.Mesh(petGeo, petMat);
        const a = (i/petals)*Math.PI*2;
        p.position.set(Math.cos(a)*radius*0.15, height + length*0.35, Math.sin(a)*radius*0.15);
        p.rotation.y = a; p.rotation.x = -Math.PI/2; p.rotation.z = lerp(-0.08,0.08,rnd());
        petalsGroup.add(p);
      }
      g.add(petalsGroup);

      // Label compact
      const label = makeFlowerLabel(f.name || ("F√©e#" + String(f.uid||"").slice(0,4)), f.ts || Date.now(), new THREE.Color(colors.petal), f.msg || "");
      label.position.set(0, height + length + 0.7, 0);
      g.add(label);

      scene.add(g);
      return g;
    }

    /************ Modal non bloquant ************/
    function askFlowerMessage(){
      return new Promise((resolve)=>{
        const modal = document.getElementById('flowerModal');
        const ta    = document.getElementById('flowerMsg');
        const bNo   = document.getElementById('fmNoMsg');
        const bYes  = document.getElementById('fmWithMsg');
        const bCancel = document.getElementById('fmCancel');

        const cleanup = ()=>{ modal.style.display = 'none'; bNo.onclick = bYes.onclick = bCancel.onclick = null; };

        modal.style.display = 'grid';
        ta.value = ""; ta.focus();

        bCancel.onclick = ()=>{ cleanup(); resolve({ proceed:false, msg:null }); };
        bNo.onclick     = ()=>{ cleanup(); resolve({ proceed:true, msg:null }); };
        bYes.onclick    = ()=>{ cleanup(); resolve({ proceed:true, msg: (ta.value||"").trim().slice(0,140) || null }); };
      });
    }

    /************ Events & Garden ************/
    const spellsRef  = ref(db, '/events/spells');
    const gardenRef  = ref(db, '/garden');

    function castAurora(){
      const p = controls.getObject().position;
      const colorHex = toHexColor(self.color, "#88e5ff");
      push(spellsRef, { uid:self.uid, x:+p.x.toFixed(2), z:+p.z.toFixed(2), color:colorHex, ts: Date.now() });
    }

    async function plantFlower(){
      const { proceed, msg } = await askFlowerMessage();
      if (!proceed) return;
      // d√©cal√© √† la frame suivante (fluidit√©)
      requestAnimationFrame(()=>{
        const p = controls.getObject().position;
        const colorHex = toHexColor(self.color, "#a0ffcc");
        push(gardenRef, {
          uid: self.uid,
          name: self.name || ("F√©e#" + self.uid.slice(0,4)),
          x: +p.x.toFixed(2),
          z: +p.z.toFixed(2),
          color: colorHex,
          ts: Date.now(),
          seed: Math.floor(Math.random()*1e9),
          ...(msg ? { msg } : {})
        });
        tint(1400, 0.16);
        trySpawnCreatureNear(p.x, p.z, colorHex);
      });
    }

    onChildAdded(query(spellsRef, limitToLast(40)), snap=>{
      const ev = snap.val(); if (!ev) return;
      if (Date.now() - (ev.ts || 0) > 15_000) return;
      const color = ev.color || "#88e5ff";
      const ring = spawnRing(ev.x, ev.z, color);
      const sparks = spawnSparks(ev.x, ev.z, color);
      liveFx.add(ring); liveFx.add(sparks);
    });

    // Fleurs persistantes
    const flowers = new Map();
    onChildAdded(query(gardenRef, limitToLast(2000)), snap=>{
      const f = snap.val(); if (!f) return;
      flowers.set(snap.key, f);
      spawnFlowerFancy(f, snap.key);
    });

    /************ Bestiaire partag√© (l√©ger) ************/
    const MAX_CREATURES = 16;
    const creaturesRef = ref(db, '/creatures');
    const creatures = new Map();

    function trySpawnCreatureNear(x, z, color="#88e5ff"){
      if (creatures.size >= MAX_CREATURES) return;
      const type = Math.random()<0.6 ? "butterfly" : "spirit";
      const y = heightFn(x,z) + 1.2;
      const seed = Math.floor(Math.random()*1e9);
      push(creaturesRef, { type, color, x0:+x.toFixed(2), y0:+y.toFixed(2), z0:+z.toFixed(2), seed, ts: Date.now() });
    }
    function makeButterflyMesh(color="#ffeeaa"){
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.2,8),
        new THREE.MeshStandardMaterial({ color: 0x333333, roughness:0.6 }));
      body.rotation.z = Math.PI/2;
      const wingMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), emissive: new THREE.Color(color).multiplyScalar(0.25), side: THREE.DoubleSide });
      const wingGeo = new THREE.PlaneGeometry(0.24, 0.17);
      const wL = new THREE.Mesh(wingGeo, wingMat);
      const wR = new THREE.Mesh(wingGeo, wingMat);
      wL.position.set(0, 0.09, 0.06); wL.rotation.y =  Math.PI/2;
      wR.position.set(0, -0.09, 0.06); wR.rotation.y = -Math.PI/2;
      g.add(body, wL, wR); g.userData = { wL, wR }; return g;
    }
    function makeSpiritMesh(color="#aaffff"){
      const m = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 12, 10),
        new THREE.MeshStandardMaterial({ color: new THREE.Color(color), emissive: new THREE.Color(color).multiplyScalar(0.5) })
      );
      const l = new THREE.PointLight(new THREE.Color(color), 0.8, 3.2, 2.0);
      l.position.set(0,0,0);
      const g = new THREE.Group(); g.add(m,l); return g;
    }
    function spawnCreatureNode(id, data){
      if (creatures.has(id)) return;
      const color = data?.color || "#88e5ff";
      const mesh = (data?.type === "butterfly") ? makeButterflyMesh(color) : makeSpiritMesh(color);
      mesh.position.set(data?.x0||0, data?.y0||1.2, data?.z0||0);
      scene.add(mesh);
      creatures.set(id, { mesh, type: data?.type||"spirit", seed: data?.seed||1, ts: data?.ts||Date.now(), color, x0:data?.x0||0,y0:data?.y0||1.2,z0:data?.z0||0 });
      tint(1300, 0.12);
    }
    onChildAdded(query(creaturesRef, limitToLast(200)), snap=>{
      const c = snap.val(); if (!c) return;
      spawnCreatureNode(snap.key, c);
    });

    function pickFlowerKeyForStep(creatureId, seed, step){
      const keys = Array.from(flowers.keys());
      if (keys.length === 0) return null;
      let s = (seed ^ (step*2654435761) ^ (creatureId.length*97531)) >>> 0;
      const rnd = ()=> (s = (s*1664525 + 1013904223) >>> 0) / 4294967296;
      const idx = Math.floor(rnd() * keys.length);
      return keys[idx];
    }

    /************ Auth & pr√©sence + HUD ************/
    const FRESH_MS = 10_000;
    const onlineEl = document.getElementById('onlineCount');
    const whoEl = document.getElementById('who');

    let self = { uid:null, name:null, color:null, sendPose: ()=>{}, _pendingName:null, _pendingColor:null };
    const selfHalo = new THREE.PointLight(0x88e5ff, 0.9, 8, 2.0); scene.add(selfHalo);

    onAuthStateChanged(auth, async (user)=>{
      if (!user) return;
      self.uid = user.uid;

      let defaultHex = "#"+new THREE.Color().setHSL(Math.random(), 0.85, 0.60).getHexString();
      const lsName  = localStorage.getItem(LS_NAME);
      const lsColor = localStorage.getItem(LS_COLOR);

      self.name  = sanitizeName(self._pendingName || lsName || ("F√©e#" + self.uid.slice(0,4)));
      self.color = toHexColor(self._pendingColor || lsColor || defaultHex);

      meRef = ref(db, `/presence/${self.uid}`);
      await set(meRef, { name:self.name, color:self.color, x:0, z:0, last: Date.now() });
      onDisconnect(meRef).remove();

      let lastSent = 0;
      self.sendPose = (x,z)=>{
        const now = performance.now();
        if (now - lastSent < 100) return; lastSent = now;
        if (!Number.isFinite(x) || !Number.isFinite(z)) return;
        update(meRef, { x:+x.toFixed(2), z:+z.toFixed(2), last: Date.now() });
      };

      onValue(ref(db, '/presence'), (snap)=>{
        const raw = snap.val() || {};
        const now = Date.now();
        const others = {};
        const list = [];
        for (const [uid, data] of Object.entries(raw)) {
          const last = (typeof data?.last === 'number') ? data.last
                      : (data?.last?.toMillis?.() ? data.last.toMillis() : 0);
          if (!last || (now - last) > FRESH_MS) continue;

          if (uid === self.uid) list.unshift({ uid, name: data?.name || "Moi", color: data?.color || "#ffffff", me:true });
          else { others[uid] = data; list.push({ uid, name: data?.name || ("F√©e#" + uid.slice(0,4)), color: data?.color || "#ffffff", me:false }); }
        }
        onlineEl.textContent = String(list.length);
        whoEl.innerHTML = "";
        for (const u of list){
          const li = document.createElement('li'); li.className = "user" + (u.me ? " me" : "");
          const dot = document.createElement('span'); dot.className = "dot"; dot.style.background = u.color;
          const name = document.createElement('span'); name.textContent = u.name + (u.me ? " (moi)" : "");
          li.appendChild(dot); li.appendChild(name); whoEl.appendChild(li);
        }
        updateAvatars(others);
      });
    });

    /************ Entr√©e / overlay ************/
    document.getElementById('startBtn').addEventListener('click', async ()=>{
      const pseudoVal = sanitizeName(pseudoEl.value);
      const colorVal  = toHexColor(colorEl.value || "#88e5ff");
      localStorage.setItem(LS_NAME,  pseudoVal);
      localStorage.setItem(LS_COLOR, colorVal);
      self._pendingName  = pseudoVal; self._pendingColor = colorVal;
      self.name  = pseudoVal; self.color = colorVal;
      document.getElementById('overlay').style.display = 'none';
      if (meRef && self.uid) { try { await update(meRef, { name: self.name, color: self.color }); } catch {} }
    });

    pseudoEl.addEventListener('change', async ()=>{
      const v = sanitizeName(pseudoEl.value);
      localStorage.setItem(LS_NAME, v); self._pendingName = self.name = v;
      if (meRef && self.uid) { try { await update(meRef, { name:v }); } catch{} }
    });
    colorEl.addEventListener('change', async ()=>{
      const v = toHexColor(colorEl.value);
      localStorage.setItem(LS_COLOR, v); self._pendingColor = self.color = v;
      if (meRef && self.uid) { try { await update(meRef, { color:v }); } catch{} }
    });

    /************ Boucle ************/
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      const t = performance.now() / 1000;

      // d√©placements
      velocity.x -= velocity.x * 10 * dt;
      velocity.z -= velocity.z * 10 * dt;
      direction.set(0,0,0);
      direction.z = Number(move.forward) - Number(move.backward);
      direction.x = Number(move.right) - Number(move.left);
      if (direction.lengthSq() > 0) direction.normalize();
      const speed = 6;
      if (move.forward || move.backward) velocity.z -= direction.z * speed * dt;
      if (move.left || move.right)       velocity.x -= direction.x * speed * dt;
        if (fireflies) tickFireflies(fireflies, dt);
      const obj = controls.getObject();
      obj.translateX(-velocity.x);
      obj.translateZ( velocity.z);
      const yHere = heightFn(obj.position.x, obj.position.z);
      obj.position.y = yHere + 1.6;

      selfHalo.color = new THREE.Color(self.color || "#88e5ff");
      selfHalo.position.copy(obj.position);
      self.sendPose(obj.position.x, obj.position.z);

      // avatars
      for (const a of avatars.values()){
        a.group.position.x += (a.target.x - a.group.position.x) * 0.15;
        a.group.position.z += (a.target.z - a.group.position.z) * 0.15;
        a.group.position.y = heightFn(a.group.position.x, a.group.position.z);
      }

      // fx
      for (const fx of Array.from(liveFx)){
        if (fx.userData?.tick){
          fx.userData.tick(dt);
          if (!fx.parent) liveFx.delete(fx);
        }
      }

      // herbe
      if (grass?.tick) grass.tick(t);

      // cr√©atures (trajectoires simples)
      const now = Date.now();
      const CYCLE_MS = 8000;
      for (const [id, c] of creatures.entries()){
        const mesh = c.mesh;
        const step = Math.floor((now - c.ts) / CYCLE_MS);
        const t01 = ((now - c.ts) % CYCLE_MS) / CYCLE_MS;
        const keyA = pickFlowerKeyForStep(id, c.seed, Math.max(0, step-1));
        const keyB = pickFlowerKeyForStep(id, c.seed, step);
        const fa = keyA && flowers.get(keyA);
        const fb = keyB && flowers.get(keyB);
        const ax = (fa?.x ?? c.x0), az = (fa?.z ?? c.z0);
        const bx = (fb?.x ?? ax), bz = (fb?.z ?? az);
        const ay = heightFn(ax, az) + 1.0;
        const by = heightFn(bx, bz) + 1.0;
        const tt = t01*t01*(3-2*t01);
        mesh.position.set(ax + (bx-ax)*tt, ay + (by-ay)*tt + Math.sin((t01+id.length)*Math.PI*2)*0.12, az + (bz-az)*tt);
        if (c.type === "butterfly" && mesh.userData?.wL && mesh.userData?.wR){
          const flap = Math.sin(now/120) * 0.9;
          mesh.userData.wL.rotation.z =  flap;
          mesh.userData.wR.rotation.z = -flap;
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    /************ Resize ************/
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>

  <!--
  ============================
  R√àGLES REALTIME DATABASE
  √Ä coller dans Firebase > RTDB > R√®gles puis "Publier"

  {
    "rules": {
      ".read": true,

      "presence": {
        "$uid": {
          ".write": "auth != null && auth.uid === $uid"
        }
      },

      "chat": {
        "global": {
          "$msgId": {
            ".write": "auth != null && newData.child('text').val().length <= 200"
          }
        }
      },

      "events": {
        "spells": {
          "$id": {
            ".write": "auth != null",
            ".validate": "newData.hasChildren(['uid','x','z','color','ts'])"
          }
        }
      },

      "garden": {
        "$id": {
          ".write": "auth != null",
          ".validate": "newData.hasChildren(['uid','name','x','z','color','ts','seed'])"
        }
      },

      "creatures": {
        "$id": {
          ".write": "auth != null",
          ".validate": "newData.hasChildren(['type','x0','y0','z0','seed','ts'])"
        }
      }
    }
  }
  ============================
  -->
</body>
</html>
